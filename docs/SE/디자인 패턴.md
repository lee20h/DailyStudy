# 디자인 패턴

## 소프트웨어 디자인 패턴

- 건축물의 설계에 빈번하게 발생하는 동일한 설계 내용이 있기 때문에, 이런 것들을 하나의 패턴으로 보고 다른 건축물 설계에 재사용하면 문제 해결에 대한 고민을 반복하지 않고 백만 번 이상 재사용 할 수 있다.
- 디자인도 소프트웨어에서 한 역할을 할 수 있다.

### 디자인 패턴의 정의

- 소프트웨어 디자인 패턴은 소프트웨어를 설게할 때 특정 상황에서 자주 사용하는 패턴을 정형화한 것이며, 좋은 소프트웨어 설계를 위한 개발자들의 경험적 산물이라 할 수 있다. 이 경험적 산물은 최적화된 알고리즘 코드일 수도 있고 클래스나 모듈들의 좋은 구조로 정의되기도 한다.

### 디자인 패턴의 특징

- 경험을 통해서 얻을 수 있다.
- 특정한 형식을 갖고 체계적으로 작성되는 것이 일반적이다.
- 패턴에는 각기 다른 추상화 수준이 존재하며 계속적으로 진화한다.
- 디자인 패턴은 소프트웨어 설계 시 개발자들에게 추천 지침으로 제공될 수 있다.
- 추천 지침은 개발자들이 설계를 빠르고 정확하게 할 수 있도록 도와주어 소프트웨어 품질을 높일 수 있다.

### 디자인 패턴의 장점

- 디자인 패턴은 의사소통에 도움을 준다. 디자인 패턴을 알고 있는 설게자들은 특정 문제에 대해 공통적으로 알고 있는 패턴을 이용해 해결책에 대한 논의를 할 수 있기 떄문에 보다 원활하게 의사소통을 할 수 있다.

- 검증된 지식인 패턴을 사용하면 높은 완성도의 디자인을 빠른 시간에 만들어 낼 수 있어 소프트웨어 개발 비용을 줄일 수 있고 경제적이다. 또한 코드의 수준을 한 단계 높여주고 적은 수의 클래스로 원하는 목적을 달성할 수 있는 환경이 제공된다.

- 좋은 설계나 아키텍처가 패턴이라는 이름으로 명명되어 있어 개발자는 그 패턴의 이름만으로도 그 소프트웨어의 구조를 알 수 있다. 이를 바탕으로 이전의 소프트웨어 개발에서 사용한 설계나 구조를 쉽게 이해할 수 있고, 새로운 소프트웨어로 빠르게 적용할 수 있어 소프트웨어 재사용을 용이하게 한다.

### Alexander의 패턴 기술 형식

- 패턴 이름
- 특정상황
- 문제점
- 해결책
- 패턴의 구조도

### 패턴의 기술 형식

- 패턴 이름과 분류
- 의도
- 다른 이름
- 동기
- 활용성
- 구조
- 참여객체
- 협력방법
- 결과
- 구현
- 예제 코드
- 잘 알려진 사용 예
- 관련 패턴

### GoF의 패턴 분류

![image](https://user-images.githubusercontent.com/59367782/100577580-e1cb4880-3323-11eb-83dd-fcb8e5ed18e7.png)

### 다형성

- 폴리모피즘이라고도 불리며, 같은 오퍼레이션이 다른 클래스에서 다르게 동작하는 것
- 하나의 함수 이름이나 연산자가 여러 목적으로 사용될 수 있는 것을 의미
- 객체지향에서의 다향성은 주로 상속 관계에서 사용되어 상위 클래스에 정의된 하나의 오퍼레이션에 대해 각 하위 클래스가 가지고 있는 고유한 방법으로 응답할 수 있도록 유연성을 제공
- 다형성은 상위 클래스를 통하여 하위 클래스의 메소드를 호출할 수 있도록 하는 개념

### 동적바인딩

- 메시지를 보내는 측에서 상위 클래스의 오퍼레이션을 호출하면 객체가 어떤 타입인지 알 필요없이 실행 시간에 개게의 타입에 따라 자동적으로 하위 클래스의 적합한 동작이 결정된다.
- 실행 시간에 하위 클래스의 객체를 통해 동작이 정해지는 것을 동적바인딩이라고 한다.
- 다형성과 동적바인딩은 디자인 패턴을 이해하기 위한 필수 개념
- 특히 GoF의 디자인패턴 분류에서 범위 분류 중 객체에 적용하는 패턴들은 대부분 다형성과 동적바인딩을 다루는 패턴들이다.

### 다형성과 동적바인딩

- 상위 클래스만 알고 있는 상태에서 컴파일되며, 하위 클래스에 대한 결정은 실행 시간에 동적바인딩을 통해 이뤄진다.
- 다형성을 통해 저마다의 기능을 가진 하위 클래스를 자유롭게 정의할 수 있으며, 새로운 하위 클래스가 기존 코드의 변경 없이 쉽게 추가될 수 있다.
- 공통적인 속성과 오퍼레이션을 상위 클래스에 정의하고 상속하게 함으로서 디자인과 코드의 중복성을 줄이고 객체지향의 장점을 극대화할 수 있다.


### Singleton 패턴

- Singleton 패턴은 클래스의 인스턴스가 오직 하나임을 보장하며 이 인스턴스에 접근할 수 있는 방법을 제공
    1. 싱글톤 패턴으로 클래스 이름 지정
    2. Private 접근 제한자를 갖는 자기 자신의 타입의 static 멤버 변수 선언
    3. Private 접근 제한자를 갖는 기본생성자를 만들어 외부에서 인스턴스를 생성할 수 없도록 함
    4. 싱글톤 객체를 반환하는 static getInstsance() 메소드 생성
        - 싱글톤 인스턴스가 생성되어 있지 않으면 생성
    5. 현재 생성된 싱글톤 인스턴스 반환

![image](https://user-images.githubusercontent.com/59367782/100578858-72a32380-3326-11eb-9c37-e63166198c54.png)

### Facade 패턴

- Facade란 건물의 앞쪽을 말하고 건물의 주된 정문으로 현관을 포함하고 있는 부분을 말한다.
- 퍼사드 패턴도 건물의 정문에 있는 안내소처럼 개발자가 사용해야 하는 서브시스템의 가장 앞쪽에 위치하고 있으면서 하위시스템에 있는 객체들을 사용할 수 있도록 하는 역할을 하게 된다.
- 따라서 퍼사드 패턴은 시스템의 복잡성을 줄이기 위해 서브시스템을 구조화하고 서브시스템으로의 접근을 **하나의 퍼사드 객체로 제공**하는 패턴이다.

![image](https://user-images.githubusercontent.com/59367782/100579145-0248d200-3327-11eb-9f40-4ad5fd689409.png)

### Facade 패턴이 필요한 경우

- 복잡한 서브시스템에 대한 단순한 인터페이스 제공이 필요할 때
- 클라이언트와 구현 클래스 간에 너무 많은 의존성의 존재하여 클라이언트와 다른 서브시스템간의 결합도를 줄일 필요가 있을 때
- 빌딩블록 아키텍쳐나 컴포넌트 기반 개발 또는 Service Oriented Architecture 등의 경우와 같이 서로의 내부 구조를 감추고 블랙박스로 이해해야 할 떄
- 서브시스템들이 계층화를 이루어 각 서브시스템의 계층별 안내소인 접근점을 제공하려 할 때

### Strategy 패턴

- 전략 패턴은 다양한 알고리즘이 존재할 때 이들 **각각을 하나의 클래스로 캡슐화**하여 알고리즘을 대체가 가능하도록 한다.
- 이를 통해 클라이언트에 영향을 주지 않고 다양한 알고리즘으로 변형할 수 있어 알고리즘을 바꾸더라도 클라이언트는 어떤 변경도 할 필요가 없다.
- 전략 패턴을 GoF의 분류적인 관점에서 다시 설명하면 알고리즘을 담당하는 각각의 클래스를 만들어 책임을 분산하기 위한 목적으로 만든 행위 패턴이고, 각각의 알고리즘을 필요한 시점에서 동적으로 변경하여 사용할 수 있기 때문에 범위적인 측면에서는 객체 패턴이다.

![image](https://user-images.githubusercontent.com/59367782/100583803-88b4e200-332e-11eb-9b79-b091441d339d.png)

### Strategy 패턴 유용하게 사용되는 경우

- 행위들이 조금씩 다를 뿐 개념적으로 관련된 많은 클래스들이 존재하는 경우, 각각의 서로 다른 행위 별로 클래스를 작성한다.
- 알고리즘의 변형이 필요한 경우에 사용할 수 있다. 저장 공간과 처리 속도 간의 절충에 따라 서로 다른 알고리즘을 사용할 수 있다.
- 많은 행위를 정의하기 위해 클래스 안에 복잡한 다중 조건문을 사용해야 하는 경우 이런 선택문 보다는 Strategy 클래스로 만드는 것이 바람직하다.
- 어떤 알고리즘이 클라이언트가 알아서는 안될 데이터를 사용하거나 알고리즘에 종속된 복잡한 자료구조를 사용할 때 유용하다.

### Factory Method 패턴

- 객체를 생성하기 위해 일정한 절차가 필요하거나 **객체를 생성하는 시점이 불명확**할 경우 객체를 생성하는 메소드를 이용할 수 있다.
- Factory Method 패턴은 객체를 생성하기 위한 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 하위 클래스에서 이뤄지도록 인스턴스 생성의 책임을 미룬다.
- 이 패턴은 **기반 클래스가 모든 일을 하지만 정확히 어떤 객체를 갖고 작업할지에 대해서는 런타임시로 미룰 때 유용**하다.

![image](https://user-images.githubusercontent.com/59367782/100584425-712a2900-332f-11eb-8887-3ee3b5d4d2f4.png)

### Adapter 패턴

- 소프트웨어 개발을 할 때 관련 라이브러리에서 제공하는 API를 사용하지 않고 개발하는 경우는 드물다.
- Adapter 패턴은 적은 비용으로 기존의 라이브러리를 사용할 수 있는 방법을 제시하고 있는 패턴이다.
- 클래스의 인터페이스를 클라이언트가 기대하는 다른 인터페이스로 변환한다.
- Adapter 패턴은 호환성이 없는 인터페이스이기 때문에 같이 사용할 수 없는 클래스를 개조하여 함께 작동하도록 해준다.

![image](https://user-images.githubusercontent.com/59367782/100584782-e85fbd00-332f-11eb-8991-b1b562ad472c.png)

### Adpater 패턴이 유용하게 사용된느 경우

- 기존의 클래스를 사용해야 하나 인터페이스가 수정되어야 하는 경우
- 아직 예측하지 못한 클래스나 실제 관련되지 않는 클래스들이 기존의 클래스를 재사용하고자 하지만, 이미 정의된 재사용 가능한 클래스가 지금 요청하는 인터페이스를 꼭 정의하고 있지 않는 경우, 즉 이미 만들어진 것을 재사용하고자 하나 이 재사용 가능한 라이브러리를 수정할 수 없는 경우

### 패턴의 남용

- 패턴을 사용하지 말아야할 곳에도 사용하게 되면 필요 이상으로 설계가 복잡해질 수 있다
- 유지보수가 어려운 소프트웨어가 만들어질 수 있다.
- 따라서 패턴에 대해 제대로 이해하고 소프트웨어의 기능이나 규모에 따라 패턴을 유연하게 사용할 수 있어야 한다.

## 요약

- 소프트웨어 디자인 패턴은 GoF의 디자인패턴에서 소개한 23개 패턴 외에도 다양하게 존재한다.
- 디자인 패턴은 과거의 경험을 검증된 해결책을 적용하여 소프트웨어 코드의 품질을 향상시키기 위한 것이며, 결과적으로 소프트웨어의 재사용성을 높이는데 그 목적이 있다.
- 디자인 패턴은 리팩토링 결과 만들어진 좋은 설계구조를 미리 포함하고 있기 때문에 디자인 패턴을 이용한 소프트웨어 설계는 리팩토링 비용을 줄여주는 효과가 있다.