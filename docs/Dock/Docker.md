---
sidebar: auto
---

# 도커

컨테이너를 사용하여 응용프로그램을 더 쉽게 만들고 배포하고 실행할 수 있도록 설계된 도구이며 컨테이너 기반의 오픈 소스 가상화 플랫폼이며 생태계이다.  

## 컨테이너

코드와 모든 종속성을 패키지화하여 응용 프로그램이 한 컴퓨팅 환경에서 다른 컴퓨팅 환경으로 빠르게 안정적으로 실행되도록 하는 소프트웨어의 표준 단위다.

서버에서의 컨테이너 개념은 다양한 프로그램, 실행환경을 컨테이너로 추상화하고 동일한 인터페이스를 제공하여 프로그램의 배포 및 관리를 단순하게 해준다.  

일반 컨테이너의 개념에서 물건을 손쉽게 운송 해주는 것처럼 프로그램을 손쉽게 이동 배포 관리를 할 수 있게 해준다.  
AWS, Azure, Google cloud 등 어디에서든 실행 가능하게 해준다.  

### 컨테이너의 이미지

코드, 런타임, 시스템 도구, 시스템 라이브러리 및 설정과 같은 응용 프로그램을 실행하는 데 필요한 모든 것들을 포함하는 가볍고 독립적이며 실행 가능한 소프트웨어 패키지이다.  

컨테이너 이미지는 런타임에 컨테이너가 되고 도커 컨테이너의 경우 도커 엔진에서 실행될 때 이미지가 컨테이너가 된다.  
리눅스와 윈도우 기반 애플리케이션 모두에서 사용할 수 있는 컨테이너화된 소프트웨어는 인프라에 관계없이 항상 동일하게 실행된다. 컨테이너는 소프트웨어를 환경으로부터 격리시키고 개발과 스테이징의 차이에도 불구하고 **균일하게 작동하도록 보장**한다.

## 도커 이미지

프로그램을 실행하는데 필요한 설정이나 종속성을 갖고 있으며, 컨테이너를 생성하여 도커 컨테이너를 이용하여 프로그램을 실행한다.  

## 도커 사용 흐름

1. 도커에 CLI에 커맨드 입력
2. 도커 서버(Daemon)이 그 커맨드를 받아 그것에 따라 이미지를 생성하든 컨테이너를 실행하든 모든 작업을 한다.


## 시작

도커 설치 이후 첫 커맨드 입력해보자.  

`docker run hello-world`  

![hello](/TIL/images/Dock/hello-world.jpg)  

입력시에 로컬에 `hello-world`라는 이미지가 없으므로 라이브러리로부터 Pulling하여서 실행한다. 그 결과는 위의 이미지와 같다.  

`docker run hello-world` -> 도커 클라이언트로 전달 -> 도커 서버 (이미지 Cache 보관 장소에서 확인) 이때, 캐시 보관 장소에 없다면, 도커 허브(이미지 보관)에서 가져온다.  

이후엔 hello-world 이미지가 캐시되었으므로, hello-world을 다시 실행하게되면 `Unable to find image~`라는 문구 없이 프로그램이 실행된다. 따라서 캐시된 이미지를 이용해서 실행된다는 것을 알 수 있다.  

## 도커와 기존의 가상화 기술과의 차이를 통한 컨테이너 이해  

**가상화 기술 나오기 전**에는 한대의 서버를 하나의 용도로만 사용하며, 남는 서버 공간은 그대로 방치되었다. 따라서 하나의 서버에 하나의 운영체제, 하나의 프로그램만을 운영하여 안정적이나, 비효율적인 방식이었다.  

**가상화 기술(하이퍼 바이저) 출현**
**하이퍼 바이저**는 호스트 시스템에서 다수 게스트 OS를 구동할 수 있게 하는 소프트웨어로, 하드웨어를 가상화하면서 하드웨어와 각각의 VM을 모니터링하는 중간 관리자이다.  

하이퍼 바이져 기반의 가상화 출현으로 논리적으로 공간을 분할하여 VM이라는 독립적인 가상 환경의 서버 이용 가능하게 되었다.  

- 네이티브 하이퍼바이저

내부 설계
| OS |
|:--:|
|하이퍼 바이저|
| 하드웨어|  

하이퍼 바이저가 하드웨어를 직접 제어하기에 자원 효율적으로 사용 가능하며, 별도의 호스트 OS가 없으므로 오버헤드가 적다. 하지만 여러 하드웨어 드라이버 세팅해야하므로 설치가 어렵다.

- 호스트형 하이퍼바이저

내부 설계
| OS |
|:-:|
| **하이퍼 바이저** |
| OS |
| 하드웨어 |

일반적인 소프트웨어처럼 호스트 OS 위에서 실행되며, 하드웨어 자원을 VM 내부의 게스트 OS에 에뮬레이트 하는 방식으로 오버헤드가 크다. 하지만 게스트 OS 종류에 대한 제약이 없고 구현이 다소 쉽다. 따라서 일반적으로 많이 이용하는 방법이다.  

### 하이퍼 바이저 기반의 VM 구조
![hypervisor](/TIL/images/Dock/hypervisor.jpg)  

하이퍼바이저에 의해 구동되는 VM은 각 VM마다 독립된 가상 하드웨어 자원을 할당받는다. 논리적으로 분리되어 있어서 한 VM에 오류가 발생해도 다른 VM으로 퍼지지 않는다.  

### Docker 구조 비교
![docker](/TIL/images/Dock/docker.jpg)  

VM과 비교했을 때 컨테이너는 하이퍼바이저와 게스트 OS가 필요하지 않으므로 더 가볍다.  

어플리케이션을 실행할 때는 컨테이너 방식에서는 호스트 OS위에 어플리케이션의 실행 패키지인 이미지를 배포하기만 하면 되는데 VM은 어플리케이션을 실행하기 위해서 VM을 띄우고 자원을 할당한 다음, 게스트 OS를 부팅하여 어플리케이션을 실행 해야해서 훨씬 복잡하고 무겁게 실행해야 한다.  

![docker](/TIL/images/Dock/docker_detail.jpg)  

### 컨테이너 격리시킬 때 사용되는 기능

리눅스에서 쓰이는 C group과 네임 스페이스에 대해서 알아야한다. 이것들은 컨테이너와 호스트에서 실행되는 다른 프로세스 사이에 벽을 만드는 리눅스 커널 기능들이다.  

C Group은 CPU, 메모리, Network Bandwidth, HD i/o 등 프로세스 그룹의 시스템 리소스 사용량을 관리한다. 어떤 어플이 사용량이 너무 많다면 그 어플리케이션 같은 것들을 C group에 집어 넣어서 CPU와 메모리 사용 제한 가능  

네임스페이스는 하나의 시스템에서 프로세스를 격리시킬 수 있는 가상화 기술로, 별개의 독립된 공간을 사용하는 것처럼 격리된 환경을 제공하는 경량 프로세스 가상화 기술이다.  

리눅스에서 쓰이는 C group과 네임 스페이스를 도커에서 사용할 수 있는 이유를 알아보자.  
먼저, 터미널에서 `docker version`쳐서 확인하게 되면, os가 리눅스로 되어있다. 이것을 설명하면 답이 될 것 같다.  

Docker 클라이언트와 서버는 리눅스 환경에서 돌아간다. 즉, 우리가 사용하는 컴퓨터 OS위에 리눅스 VM이 있어서, 그 곳이 도커의 환경이 된다. 따라서 컨테이너와 이미지를 나눌 때 C Group과 네임 스페이스를 통해서 분리할 수 있다.  


## 이미지로 컨테이너 만들기

이미지는 응용 프로그램을 실행하는데 **필요한 모든 것**을 포함하고 있다. 이때의 **필요한 모든 것**에 대해 알아보자  

1. 컨테이너가 시작 될 명령어 ex) run kakaotalk
2. 파일 스냅샷 ex) 컨테이너에서 카카오톡을 실행하고 싶다면 카카오톡 파일 스냅샷

※ 이때의 파일 스냅샷이란, 디렉토리나 파일을 카피 한것  

### 이미지로 컨테이너 만드는 순서

1. Docker 클라이언트에 `docker run <이미지>` 입력해준다.  

2. 도커 이미지에 있는 파일 스냅샷을 컨테이너 하드 디스크에 옮겨 준다.

3. 이미지에서 가지고 있는 명령어(컨테이너 실행시 사용될 명령어)를 이용해서 스냅샷을 실행시켜준다.

---

## 도커 클라이언트 명령어

## 이미지 내부 파일 시스템

| docker | run | 이미지 이름 | 커맨드 |
|---|---|---|---|
| 도커 클라이언트 언급 | 컨테이너 생성 및 실행 | 이 컨테이너를 위한 이미지 | 이 자리는 원래 이미지가 가지고 있는 시작 명령어를 무시하고 여기에 있는 커맨드를 실행 |  

예를 들어서 명령어를 통해 이해해보자.  
`docker run alpine ls` alpine 이미지의 명령어를 `ls`명령어로 대체하여 alpine 이미지에서 실행된다.  

하지만 전에 했던 명령어인 `docker run hello-world`를 ls 명령어를 이용해서 사용하게 되면 에러가 난다. 왜냐하면 alpine 이미지 파일 스냅샷 안에 ls를 사용 가능하게 하는 파일이 있기 때문이다. 즉, hello-world 이미지에는 ls을 실행하게 하는 파일이 없다.  

따라서 파일 하드디스크안에 들어오는 스냅샷에 무엇이 있는지에 따라서 커맨드의 사용 가능 여부가 결정된다.  

## 컨테이너 나열

`docker ps`를 통해서 도커 클라이언트의 process status을 체크해보자. 

1. `docker alpine ping localhost`를 통해서 핑을 계속 보낸다.

2. 다른 터미널에서 `docker ps`를 통해서 컨테이너들을 확인해본다.

이러한 방법으로 체크를 하게 되면 컨테이너를 확인할 수 있다. 이때의 속성들을 적어봤다.  

- CONTAINER ID : 컨테이너의 고유한 아이디 해시값으로 일부분만 출력
- IMAGE : 컨테이너 생성시 사용한 도커 이미지
- COMMAND : 컨테이너 시작시 실행될 명령어로, 대부분 내장되어 있으므로 별도 설정 필요가 없다.
- CREATED : 컨테이너 생성 식나
- STATUS : 컨테이너의 상태로 실행중은 Up, 종료는 Exited, 일시정지는 Pause로 나온다.
- PORTS : 컨테이너가 개방한 포트와 호스트에 연결한 포트로, 특별한 설정을 하지 않은 경우 출력되지 않는다.
- NAMES : 컨테이너 고유한 이름으로 컨테이너 생성시 `--name` 옵션으로 이름을 설정하지 않으면 도커 엔진이 임의로 형용사와 명사를 조합해서 설정한다. id와 마찬가지로 중복이 안되고 `docker rename` 명령어로 이름을 변경할 수 있다. ex) `docker rename origianl-name changed-name`  


### 원하는 항목만 보기

`docker ps --format 'table{{.Names}} \t 'table{{.Image}}` 이러한 명령어로 원하는 항목만 볼 수 있다. `--format` 옵션을 사용하여 Names와 Image 항목만 볼 수 있다. 이때의 `\t`는 탭 공백을 의미한다.  

이외 모든 항목을 보고자 할때는 `docker ps -a`을 사용하면 된다. `-a`는 -all로, 꺼져있는 컨테이너도 확인할 수 있다.  


## 도커 컨테이너의 생명 주기

생명주기  

생성 -> 시작 -> 실행 -> 중지 -> 삭제  

### 생성부터 실행까지

`docker run` = `docker create <이미지 이름>` + `docker start <컨테이너 아이디/이름>`  

`docker create`을 사용하면 컨테이너의 ID가 출력이 된다. 이후 컨테이너의 아이디 중 일부를 `docker start` 뒤에 붙여주면 된다. 이때 `docker start`에 옵션이 존재하는데 바로 `-a` 옵션이다. 이것은 attach을 의미하며 실행이 될 때 붙어있다가 출력값들을 화면에 출력시킬 수 있게 보내주는 옵션이다. 이 옵션이 없이 `docker start ID`만 입력하게 되면 컨테이너 ID만 다시 출력하고 끝나게 된다.  

### 중지

중지 부분에는 두 가지 방법이 있다. 바로 `docker stop`과 `docker kill`이다.  
`docker stop <컨테이너ID/NAMES>`, `docker kill <컨테이너ID/NAMES>`로 문법도 유사하다.  

공통점은 실행중인 컨테이너를 중지시킨다.  

차이점은 Stop의 경우를 먼저 보면, Gracefully하게 중지를 시킨다. 즉, 그동안 하던 작업들을 완료하고 컨테이너를 중지시킨다.  

그에 반해, Kill은 Stop과 달리 기다리지 않고 바로 컨테이너를 중지 시킨다.  

이것을 구조적으로 보게 되면,  

`docker stop -> Sigterm -> Sigkill -> Container(main process)`  

`docker kill -> Sigkill -> Container(main process)`  

Stop은 Sigterm에서 Grace Period(정리 하는 시간)을 갖고 작업들을 완료한 뒤, 컨테이너를 중지시키는 시간을 갖게 된다.   
Kill은 이러한 시간이 없이 바로 중지시키기 때문에 결과가 차이가 난다.  

### 삭제

컨테이너 삭제는 중지 시킨 뒤 삭제가 가능하다.  
명령어는 `docker rm <중지된 컨테이너 ID/NAMES>`이다. 이 경우에는 각각 컨테이너의 이름이나 ID를 통해 하나하나 지울 수 있다.  

컨테이너를 모두 지울려면 다음과 같다.  
```
docker rm `docker ps -a -q`
```

이미지의 삭제는 `docker rmi <이미지 id>`를 통해서 하나씩 삭제할 수 있다.  

나중에 도커를 많이 이용하게되면 용량이 많이 쌓이게 된다. 이럴 때 도커를 사용하지 않은 경우 용량이 부담이 될 수 있다. 따라서 전부 삭제하는 부분을 봐보자. 이 명령어는 컨테이너, 이미지, 네트워크를 모두 삭제할 수 있다. 하지만, 현재 실행 중인 컨테이너는 지워지지 않으므로 편리하다.  
명령어는 `docker system prune`으로, 삭제한 뒤 삭제한 용량을 보여준다.  

## 실행중인 컨테이너에 명령어 전달

이미 실행중인 컨테이너에 명령어를 전달하고 싶을 때 사용하는 명령어  

`docker exec <컨테이너 ID> <명령어>`  

결과만 따지자면 위에서 공부한 `docker run <컨테이너 ID> <명령어>`와 같다. 하지만, run의 경우에는 새로 컨테이너를 만들어서 실행하고 exec은 이미 만들어진 컨테이너가 실행 중일 때만 사용할 수 있다.  

## 레디스를 이용한 컨테이너 이해

### 레디스의 작동

레디스 서버를 실행한 후, 레디스 클라이언트를 통해서 서버에 명령어를 전달해 줘야 한다.  
레디스 클라이언트 `set value1 hello` -> 레디스 서버  

이 부분을 도커를 통해 실행해보자.  

1. 먼저 첫 터미널로 레디스 서버를 작동 시키자.

2. 그 후 레디스 클라이언트를 키기 위해 다른 터미널을 켜 레디스 클라이언트를 다음 명령어로 작동시킨다. `redis-cli`을 작성한다.

3. 에러가 존재한다.  

에러의 이유를 찾아보면, 컨테이너 속에 레디스 서버가 동작 중인데, 레디스 클라이언트가 컨테이너 밖에서 실행을 할려하자 거부를 당하였다. 이러한 경우를 해결하기 위해서는 레디스 클라이언트도 레디스 서버와 같은 컨테이너 속에서 실행을 시켜야한다. 그러기 위해서는 이러한 명령어로 사용한다.  

`docker exec -it <컨테이너 아이디> redis-cli`  

위에서 공부한 `docker exec`를 이용해서 컨테이너 속에서 켜진 레디스 서버에 레디스 컨테이너를 켜보자.  

여기서 `-it`를 처음보는데 이 옵션은 interactive terminal을 따로 나눠서 붙인 약자로, exec를 통한 실행 후 다음 명령어를 입력할 수 있는 옵션이다. 따라서, `-it` 옵션이 없다면 레디스 클라이언트를 실행 후 바로 나와서 이어서 사용하지 못한다.  

## 마지막으로

지금까지 배운 내용으로는 실행중인 컨테이너에 명령어를 전달할 때에는 `docker exec -it <컨테이너 ID> <명령어>` 전부를 다 타이핑해서 사용하였다. 이러한 문제를 해결해주기 위한 방법이 있다.  

쉘이나 터미널 환경으로 접속을 하게 되면, 앞의 여러 명령어를 줄일 수 있다. 그 방법은 바로 `docker exec -it <컨테이너 ID> <명령어>`에서 명령어 부분에 `sh`, `bash`, `zsh`, `powershell`을 사용하면 된다. 이때 쉘 환경에 맞춰서 사용하면 된다. 여기서 exec가 아닌 run으로도 충분히 사용이 가능하다.

쉘에 접근해서 사용하고 나서 나오고 싶을 때 컨트롤 + C를 통해서 쉘에서 빠져나오질 못한다. 컨트롤 + D를 통해서만 나올 수 있으므로 주의해줘야한다.
