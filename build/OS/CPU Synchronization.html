<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>CPU Synchronization | Today 20h Learned</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="Today I Learned">
    <link rel="preload" href="/TIL/assets/css/0.styles.f9c21fbc.css" as="style"><link rel="preload" href="/TIL/assets/js/app.30710a52.js" as="script"><link rel="preload" href="/TIL/assets/js/2.5e371023.js" as="script"><link rel="preload" href="/TIL/assets/js/19.47410111.js" as="script"><link rel="prefetch" href="/TIL/assets/js/10.de71ead9.js"><link rel="prefetch" href="/TIL/assets/js/11.b6dbdb05.js"><link rel="prefetch" href="/TIL/assets/js/12.3d811d17.js"><link rel="prefetch" href="/TIL/assets/js/13.58f77890.js"><link rel="prefetch" href="/TIL/assets/js/14.75d16e65.js"><link rel="prefetch" href="/TIL/assets/js/15.e2013ae5.js"><link rel="prefetch" href="/TIL/assets/js/16.7d37f6e5.js"><link rel="prefetch" href="/TIL/assets/js/17.badd1712.js"><link rel="prefetch" href="/TIL/assets/js/18.ba75afc9.js"><link rel="prefetch" href="/TIL/assets/js/20.74b007e3.js"><link rel="prefetch" href="/TIL/assets/js/21.a41e82c8.js"><link rel="prefetch" href="/TIL/assets/js/22.d42518a4.js"><link rel="prefetch" href="/TIL/assets/js/23.d4217736.js"><link rel="prefetch" href="/TIL/assets/js/24.078a5a36.js"><link rel="prefetch" href="/TIL/assets/js/25.a9604b67.js"><link rel="prefetch" href="/TIL/assets/js/26.f4c362e9.js"><link rel="prefetch" href="/TIL/assets/js/27.c7f6a8a3.js"><link rel="prefetch" href="/TIL/assets/js/28.9d63dfcb.js"><link rel="prefetch" href="/TIL/assets/js/29.c1755c1f.js"><link rel="prefetch" href="/TIL/assets/js/3.19c023e1.js"><link rel="prefetch" href="/TIL/assets/js/30.30047879.js"><link rel="prefetch" href="/TIL/assets/js/4.ea0cffe1.js"><link rel="prefetch" href="/TIL/assets/js/5.d60f48c3.js"><link rel="prefetch" href="/TIL/assets/js/6.f92cd4ca.js"><link rel="prefetch" href="/TIL/assets/js/7.e99ba390.js"><link rel="prefetch" href="/TIL/assets/js/8.7659ef59.js"><link rel="prefetch" href="/TIL/assets/js/9.8995e469.js">
    <link rel="stylesheet" href="/TIL/assets/css/0.styles.f9c21fbc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/TIL/" class="home-link router-link-active"><!----> <span class="site-name">Today 20h Learned</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/lee20h/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/lee20h/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>CPU Synchronization</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/TIL/OS/CPU%20Synchronization.html#race-condition" class="sidebar-link">Race Condition</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/TIL/OS/CPU%20Synchronization.html#critical-section" class="sidebar-link">Critical Section</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TIL/OS/CPU%20Synchronization.html#하드웨어적-해결법" class="sidebar-link">하드웨어적 해결법</a></li></ul></li><li><a href="/TIL/OS/CPU%20Synchronization.html#cpu동기화에-신경써야할-문제-3가지" class="sidebar-link">CPU동기화에 신경써야할 문제 3가지</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TIL/OS/CPU%20Synchronization.html#_1-bounded-buffer-problem" class="sidebar-link">1) Bounded-Buffer Problem</a></li><li class="sidebar-sub-header"><a href="/TIL/OS/CPU%20Synchronization.html#_2-readers-writers-problem" class="sidebar-link">2) Readers-Writers Problem</a></li><li class="sidebar-sub-header"><a href="/TIL/OS/CPU%20Synchronization.html#_3-dining-philosophers-problem" class="sidebar-link">3) Dining-Philosophers Problem</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="cpu-synchronization"><a href="#cpu-synchronization" class="header-anchor">#</a> CPU Synchronization</h1> <h2 id="race-condition"><a href="#race-condition" class="header-anchor">#</a> Race Condition</h2> <p>CPU 동기화하는데에 있어 <strong>Race Condition</strong> 문제점이 있는데</p> <div class="language- extra-class"><pre class="language-text"><code>//count = 5일때 counter++, counter-- 연산
S0: producer execute register1 = counter {register1 = 5}  
S1: producer execute register1 = register1 + 1 {register1 = 6}  
S2: consumer execute register2 = counter{register2 = 5}  
S3: consumer execute register2 = register2 –1 {register2 = 4}  
S4: producer execute counter = register1 {counter = 6 }  
S5: consumer execute counter = register2 {counter = 4}
</code></pre></div><p>이런식으로 실행할 때마다 답이 달라지는 경우를 Race Condition이라고 한다.</p> <h2 id="critical-section"><a href="#critical-section" class="header-anchor">#</a> Critical Section</h2> <p>프로세스끼리 변수를 공유하여 만들어진 시스템에 있어서 같은 변수를 사용하거나 table을 업데이트하거나 file을 쓰는 코드가 쓰인 부분을 <strong>Critical Section</strong>이라고 한다.<br>
Critical Section은 Entry Section과 Exit Section으로 나누어지는데 나머지를 Remainder Section이라 부른다.<br> <img src="https://www.geeksforgeeks.org/wp-content/uploads/gq/2015/06/critical-section-problem.png" alt="Critical Section"><br>
Critical Section은 3가지 필요조건을 만족해야한다.<br> <em>1. Mutual Exclusion</em> - 한 프로세스가 C-S을 수행중이라면 다른 프로세스들은 C-S을 수행할 수 없다.<br> <em>2. Progress</em> - C-S을 수행하는 프로세스가 없고 C-S을 수행하고자하는 프로세스가 있을 때 반드시 수행되어야 한다.<br> <em>3. Bounded Waiting</em> - C-S을 요청한 프로세스는 무한히 대기하면 안된다.<br>
이 세가지 조건을 다 만족한 Peterson's Solution을 봐보자</p> <div class="language- extra-class"><pre class="language-text"><code>// int turn = 0; bool flag[3]; flag[1] = flag[2] = false;
//Process P₁			|	//Process P₂
flag[1] = true;			|	flag[2] = true;
turn = 1;			|	turn = 0;
while (flag[2] &amp;&amp; (turn == 1));	|	while (flag[1] &amp;&amp; (turn == 0));
	critical section	|		critical section
flag[1] = false;		|	flag[2] = false;
	remainder section	|		remainder section
</code></pre></div><p>이러한 3가지 조건을 만족하는 해결법은 크게 소프트웨어적, 하드웨어적 해결법으로 나뉜다.<br>
소프트웨어적 해결법은 test_and_set과 compare_and_swap 등이 있다.</p> <div class="language- extra-class"><pre class="language-text"><code>boolean test_and_set (boolean * target) {
	boolean rv = *target;
	*target = TRUE;
	return rv;
}
// 인자 값을 그대로 반환하되, 인자를 TRUE로 변경한다.
do{
	while (test_and_set(&amp;lock)); /* do nothing */
		/* critical section */
	lock = false;
		/* remainder section */
	} while (true);
// lock이 false로 초기화되어있으므로 처음엔 바로 C-S을 수행하지만 lock이 true가 되어 다른 프로세스들은 수행하지 못한다. 이후 lock을 바꾸면서 수행하여 Mutual Exclusion 조건을 해결하였다.

do {
	waiting[i] = true;
	key = true;
	while (waiting[i] &amp;&amp; key)
		key = test_and_set(&amp;lock);
	waiting[i] = false;
	/* critical sectioin */
	next = (i+1) % n;
	while ((next != i) &amp;&amp; !waiting[next])
		next = (next + 1) % n;
	if (next == i)
		lock = false;
	else
		waiting[next] = false;
	/*remainder section */
} while (true);
이 코드는 Bounded Waiting도 해결한 코드이다.
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>int compare_and_swap(int *value, int expected, int new_value) {
	int temp = *value;
	if (*value == expected)
		*value = new_value;
	return temp;
}
do {
	while (compare_and_swap(&amp;lock, 0, 1) != 0);
			/* do nothing */
		/* ciritcal section */
	lock = 0;
		/* remainder section */
	} while (true);
이 방법 또한 Mutual exlusion 을 해결했다. 차이점은 반환형이 다르다는 점이다.
</code></pre></div><h3 id="하드웨어적-해결법"><a href="#하드웨어적-해결법" class="header-anchor">#</a> 하드웨어적 해결법</h3> <p>하드웨어적 해결법은 3가지가 있다.<br> <strong>1. Mutex lock (spinlock)</strong> - 가장 기본적인 형태의 방법이다. acquire()와 release()로 잠금과 잠금해제를 한다. 잠그면 CS에 접근할 수 없다. test__and_set과 비슷하나, busy wait을 사용하므로 cpu를 계속 사용한다. 빠른 진입이 가능하나, CPU가 낭비된다. 따라서 CPU을 낭비 안할 때나, 금방 이용가능 할 때, Critical Section이 짧은 경우 사용되면 좋다.<br> <strong>2. Semaphore</strong> - Binary와 Counting으로 나뉘어서 spinlock과 비슷하게 P() == wait()과 V() == signal()을 사용한다. Counting Semaphore는 Critical Section에 들어갈 수 있는 프로세스 갯수를 S 변수에 넣어 여러개로 관리가 가능하다. Binary Semaphore은 Mutex Lock와 같다. Busy wait을 사용유무로 종류가 네 가지가 나온다. 그 중에 일반적인 세마포어는 Counting하며, Non-busy wait을 사용하는 세마포어이다. 따라서 context switch 시간보다 길고 연산외에 시스템콜이나 예측불가한 작업시에는 세마포어를 사용하고 Critical Section 진입이 시간이 짧다면 스핀 락을 사용하는게 맞다.<br> <em>3. Monitor</em> - 가장 high-level부분으로 가장 사용하기 편한 방법이라고 하나 크게 다루지 않았다.<br>
추가적으로 Deadlock과 Starvation이 있는데<br>
먼저 Deadlock은 여러 프로세스들이 수행될 때 프로세스 전부 wait상태에 빠진 경우다.<br>
Starvation은 특정 프로세스의 우선순위가 낮아서 자원 할당을 받지 못하는 경우이다.</p> <h2 id="cpu동기화에-신경써야할-문제-3가지"><a href="#cpu동기화에-신경써야할-문제-3가지" class="header-anchor">#</a> CPU동기화에 신경써야할 문제 3가지</h2> <h3 id="_1-bounded-buffer-problem"><a href="#_1-bounded-buffer-problem" class="header-anchor">#</a> 1) Bounded-Buffer Problem</h3> <p>Bounded-Buffer Problem은 생산자와 소비자가 같은 버퍼를 점유할 때 일어나는 문제이다.<br> <img src="/img/OS/Bounded-Buffer.JPG" alt="Bounded-Buffer"> <em>Bounded-Buffer Problem Solution</em><br>
Empty : 버퍼 내에 저장할 공간이 있음을 표시, 생산자의 진입을 관리<br>
Full : 버퍼 내에 소비할 아이템이 있음을 표시, 소비자의 진입을 관리<br>
Mutex : 버퍼에 대한 접근을 관리, 생산자와 소비자가 empty, full 세마포어에 진입한 경우 버퍼의 상태 값을 변경하기위한 세마포어<br>
세마포어 value의 초기값은 full = 0, empty = n, mutex = 1로 생산자와 소비자의 프로세스을 정리한다.</p> <div class="language- extra-class"><pre class="language-text"><code>생산자 프로세스		            			|소비자 프로세스      
    Do {		        		        	|Do {
	...				                        |	wait(full);
	/* produce an item in next_produced */	|	wait(mutex);
	...                     				|	...
	wait(empty);			            	|	/* remove an item from buffe to next_consumed */
	wait(mutex);                        	|	...
	...         							|	signal(mutex);
	/* add next produced to the buffer */	|	signal(empty);
	...			                        	|	...
	signal(mutex);		            		|	/* consume the item in next consumed */
	siganl(full);	            			|	...
} while(true);				            	|} while(true);
</code></pre></div><h3 id="_2-readers-writers-problem"><a href="#_2-readers-writers-problem" class="header-anchor">#</a> 2) Readers-Writers Problem</h3> <p><em>Readers-Writers Problem</em>은<br> <img src="/img/OS/Readers-Writers.JPG" alt="Readers-Writers"></p> <ul><li>Readers : 공유 데이터를 읽는다.
<ul><li>여러 Reader는 동시에 데이터를 접근할 수 있다.</li></ul></li> <li>Writers : 공유 데이터에 쓴다.
<ul><li>Writer가 데이터를 수정할 때는 reader나 다른 writer가 접근하면 안된다.</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>/* do while 생략 */
1)  
Writer				            		    Reader
wait(wrt);		//entry section			    wait(mutex);
		...			    	                readcount++;
writing is performed // critical section    if (readcount == 1)
		...		            			        wait(wrt);		//어떤 writer도 수행X
signal(wrt);	//exit section			    signal(mutex);
					                		... reading is performed... // critical section
				                	    	wait(mutex);
				                		    readcount--;
				                		    if (readcount == 0)	
			                				    signal(wrt);
				                		    signal(mutex);
</code></pre></div><p>이때 Writer의 Starvation이 일어난다. 그 이유는 계속 Reader들이 진입하게되면 Writer는 Critical section에 진입할 수 없기 때문이다.</p> <div class="language- extra-class"><pre class="language-text"><code>2)
Writer					                    	|	Reader
wait(wmutex); // Writer Process entry section	|	wait(read); // Reader Process entry section
writedcount++;			                		|	signal(read);
if (writecount == 1)	            			|	wait(rmutex);
	wait(read);		                    		|	readcount++;
signal(wmutex);				                	|	if (readcount == 1)
wait(wrt);	                       				|		wait(wrt);
...writing is performed... // critical section	|	signal(rmutex);
signal(wrt); // Writer Process exit section	    |	...reading is performed... // critical section
wait(wmutex);	                				|	wait(rmutex); // Reader Process exit sectioin
writecount--;					                |	readcount--;
if (writecount == 0)		            		|	if (readcount == 0)
	signal(read);			                	|		signal(wrt);
signal(wmutex);			                		|	signal(rmutex);
</code></pre></div><p><code>1)</code>의 Writer의 starvation을 해결하기 위해 짜여졌으나 <code>2)</code>에서는 Reader들이 오히려 starvation에 빠지게 된다.<br>
Reader가 초기값으로 진입했다면 Reader들이 계속 진입하다가 Writer가 진입하게되면 진입한 Reader이 모두 수행하면 Writer가 수행된다. 이 때 Reader가 더 이상 진입하지 못하여 Starvation이 일어난다.<br>
또, Writer가 초기값으로 진입해서 계속 Writer만 진입한다면 Reader가 Starvation에 빠지게 된다.</p> <div class="language- extra-class"><pre class="language-text"><code>3)
Writer				                    		|	Reader
wait(mutex); // Writer Process entry section	|	wait(mutex); // Reader Process entry section
if(rc&gt;0 || wc&gt;0 || rwc&gt;0 || wwc&gt;0) {	    	|	if(wc&gt;0 || wwc&gt;0) {
	wwc++;	                    				|		rwc++;  
	signal(mutex);		                       	|		signal(mutex);
	wait(wrt);				                    |		wait(read);
	wait(mutex);			                    |		wait(mutex);
	wwc--;				                    	|		rwc--;
}							                    |	}
wc++;						                    |	rc++;
signal(mutex);			                    	|	signal(mutex);
...writing is performed // critical section	    |	...reading is performed // critical section
wait(mutex); // Writer Process exit section	    |	wait(mutex); // Reader Process exit section
wc--;						                	|	rc--;
if(rwc&gt;0) {					                	|	if(rc == 0 &amp;&amp; wwc&gt;0)
	for (i=0; i&lt;rwc; i++)	                	|		signal(wrt);
		signal(read);		                	|	signal(mutex);
}							                	|
else						                	|
	if (wwc&gt;0) signal(wrt);	                	|
signal(mutex);				                	|
</code></pre></div><p><code>3)</code>의 경우에는 모든 문제가 해결되어 동기화가 잘 이루어진다.<br>
Writer는 작업이 수행되거나 대기중인 다른 reader, writer가 있다면 대기한다. 그리고 수행 후 대기중인 reader들을 모두 수행한다.<br>
Reader는 writer가 기다리거나 작업중이라면 대기한다. Reader가 다 수행되면 대기 중인 writer을 수행한다.</p> <h3 id="_3-dining-philosophers-problem"><a href="#_3-dining-philosophers-problem" class="header-anchor">#</a> 3) Dining-Philosophers Problem</h3> <p><img src="/img/OS/Dining-Philosophers.JPG" alt="Dining-Philosopher"><br> <em>Dining-Philosophers Problem</em>은 젓가락이 5개가 있을 때 자신과 이웃한 젓가락만 들 수 있으며 젓가락을 2개 들었을 때 식사가 가능하다.</p> <div class="language- extra-class"><pre class="language-text"><code>1)
do {
		...
		think
		...
	wait(chopstick[i])
	wait(chopstick[(i+1) % 5])
		...
		eat
		...
	signal(chopstick[i])
	signal(chopstick[(i+1) % 5])
		...
} while(1);
</code></pre></div><p>동시에 젓가락을 집으면 deadlock이 발생한다.</p> <div class="language- extra-class"><pre class="language-text"><code>2)
do {
		...
		think
		...
	take_chopsticks(i);
		...
		eat
		...
	put_chopsticks(i)
		...
} while(1);

take_chopstics(int i) {		|		put_chopsticks(int i) {
	wait(mutex);	    	|			wait(mutex);
	state[i] = HUNGRY;		|			state[i] = THINK;
	test(i);		    	|			test(LEFT);
	signal(mutex);	    	|			test(RIGHT);
	signal(self[i]);		|			signal(mutex);
}		            		|		}

test(int i) {
	if (state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] != EATING) {
		state[i] = EATING;
		signal(self[i]);
	}
}
</code></pre></div><p><code>2)</code>의 전략은 철학자들이 좌우 젓가락이 사용 가능할 때 critical section에 진입하여 deadlock과 starvation을 해결하였다.</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/TIL/assets/js/app.30710a52.js" defer></script><script src="/TIL/assets/js/2.5e371023.js" defer></script><script src="/TIL/assets/js/19.47410111.js" defer></script>
  </body>
</html>
