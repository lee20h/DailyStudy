<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Data Types | Today 20h Learned</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="Today I Learned">
    <link rel="preload" href="/TIL/assets/css/0.styles.f9c21fbc.css" as="style"><link rel="preload" href="/TIL/assets/js/app.023881f9.js" as="script"><link rel="preload" href="/TIL/assets/js/2.5e371023.js" as="script"><link rel="preload" href="/TIL/assets/js/17.f2f7033c.js" as="script"><link rel="prefetch" href="/TIL/assets/js/10.3f780f5d.js"><link rel="prefetch" href="/TIL/assets/js/11.61deb296.js"><link rel="prefetch" href="/TIL/assets/js/12.8f5792e9.js"><link rel="prefetch" href="/TIL/assets/js/13.a4d8b86d.js"><link rel="prefetch" href="/TIL/assets/js/14.3141b341.js"><link rel="prefetch" href="/TIL/assets/js/15.456c9aa4.js"><link rel="prefetch" href="/TIL/assets/js/16.d15408d0.js"><link rel="prefetch" href="/TIL/assets/js/18.d3ca7e9c.js"><link rel="prefetch" href="/TIL/assets/js/19.3460a969.js"><link rel="prefetch" href="/TIL/assets/js/20.e048387d.js"><link rel="prefetch" href="/TIL/assets/js/21.fe90ea5a.js"><link rel="prefetch" href="/TIL/assets/js/22.4d2c2356.js"><link rel="prefetch" href="/TIL/assets/js/23.a9257da5.js"><link rel="prefetch" href="/TIL/assets/js/24.5a632101.js"><link rel="prefetch" href="/TIL/assets/js/25.0bda93d0.js"><link rel="prefetch" href="/TIL/assets/js/3.19c023e1.js"><link rel="prefetch" href="/TIL/assets/js/4.1d324b29.js"><link rel="prefetch" href="/TIL/assets/js/5.d60f48c3.js"><link rel="prefetch" href="/TIL/assets/js/6.4b5555ee.js"><link rel="prefetch" href="/TIL/assets/js/7.62d02473.js"><link rel="prefetch" href="/TIL/assets/js/8.64a73cfc.js"><link rel="prefetch" href="/TIL/assets/js/9.0a74ec9e.js">
    <link rel="stylesheet" href="/TIL/assets/css/0.styles.f9c21fbc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/TIL/" class="home-link router-link-active"><!----> <span class="site-name">Today 20h Learned</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/lee20h/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/lee20h/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Data Types</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/TIL/PL/Data%20Types.html#primitive-data-types" class="sidebar-link">Primitive data types</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TIL/PL/Data%20Types.html#numeric-types" class="sidebar-link">Numeric types</a></li></ul></li><li><a href="/TIL/PL/Data%20Types.html#structured-data-types" class="sidebar-link">Structured data types</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TIL/PL/Data%20Types.html#string" class="sidebar-link">string</a></li><li class="sidebar-sub-header"><a href="/TIL/PL/Data%20Types.html#enumeration-type" class="sidebar-link">Enumeration type</a></li><li class="sidebar-sub-header"><a href="/TIL/PL/Data%20Types.html#array-types" class="sidebar-link">Array Types</a></li><li class="sidebar-sub-header"><a href="/TIL/PL/Data%20Types.html#record-types" class="sidebar-link">Record Types</a></li><li class="sidebar-sub-header"><a href="/TIL/PL/Data%20Types.html#tuple-types" class="sidebar-link">Tuple Types</a></li><li class="sidebar-sub-header"><a href="/TIL/PL/Data%20Types.html#list-types" class="sidebar-link">List Types</a></li><li class="sidebar-sub-header"><a href="/TIL/PL/Data%20Types.html#unions-types" class="sidebar-link">Unions Types</a></li><li class="sidebar-sub-header"><a href="/TIL/PL/Data%20Types.html#pointer-and-reference-types" class="sidebar-link">Pointer and Reference Types</a></li><li class="sidebar-sub-header"><a href="/TIL/PL/Data%20Types.html#heap-management" class="sidebar-link">Heap Management</a></li></ul></li><li><a href="/TIL/PL/Data%20Types.html#type-checking" class="sidebar-link">Type Checking</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TIL/PL/Data%20Types.html#요약" class="sidebar-link">요약</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="data-types"><a href="#data-types" class="header-anchor">#</a> Data Types</h1> <ol><li><strong>표현</strong></li> <li><strong>연산</strong></li></ol> <p>자료형은 2가지를 고려해야한다. 이 부분을 생각하면서 공부하자</p> <p>Data type : 데이터의 모음과 미리 정의된 연산들의 모음</p> <p>descriptor : 변수의 속성들의 모음<br>
모든 속성들은 정적이라서 컴파일 시간까지만 필요하다.(Symbol table에 유지) 따라서 런타임에는 value만 유지한다.</p> <p>object : 상속을 제외한 추상 데이터</p> <h2 id="primitive-data-types"><a href="#primitive-data-types" class="header-anchor">#</a> Primitive data types</h2> <p>가장 기본적인 data type<br>
비트마다 하드웨어에 기반해서 data type을 정함</p> <h3 id="numeric-types"><a href="#numeric-types" class="header-anchor">#</a> Numeric types</h3> <ul><li><p>integer<br>
음의 정수 표현</p> <ul><li>Sign-magnitude notation (MSB가 부호비트)<br>
산술문제가 존재 (0011 (3) + 1011 (-3) ≠ 0)</li> <li>Two's complement notation<br>
보수 취하고 1을 더함<br>
대부분 사용함</li> <li>One's complement notation<br>
0을 표현하는 방법이 2가지가 있음 (1111, 0000)</li></ul></li> <li><p>floating point<br>
표현방법</p> <ul><li>Fixed-point notation<br>
1.3<br>
0001 | 0011<br>
0.03 같은 숫자 표현 불가</li> <li>Floating-point notation<br>
0.13 x 10¹<br>
0111 | 0001<br>
이러한 원리로 작동한다.<br>
0.03 = 0.3 x 10^(-1)도 같이 표현할 수 있다.</li></ul></li> <li><p>complex<br>
real + imaginary</p></li> <li><p>decimal<br>
C언어에서 제공 X<br>
은행에서 많이 사용함 (COBOL)<br>
BCD : 0,1로 코딩된 십진법을 사용함<br>
4bit or 8bit 사용<br>
ex) 123<br>
4 bit : 0001 0010 0011<br>
8 bit : 00000001 00000010 00000011<br>
장점 : 정확성<br>
단점 : 범위 한계, 메모리 낭비</p></li> <li><p>boolean<br>
true or false<br>
byte 단위로 표현 (bit로 하면 연산시 복잡함)<br>
장점 : 가독성</p></li> <li><p>character<br>
숫자 -&gt; 문자 매핑
ASCII 이용<br>
영어 외의 언어 Unicode</p></li></ul> <h2 id="structured-data-types"><a href="#structured-data-types" class="header-anchor">#</a> Structured data types</h2> <p>primitive data type들을 구조화 시킨 data type</p> <h3 id="string"><a href="#string" class="header-anchor">#</a> string</h3> <ul><li><p>issue<br>
primitive로 볼지, char형의 배열로 볼지<br>
string의 길이를 정적으로 할지 동적으로 할지 (hi -&gt; hello, hello -&gt; hi)</p></li> <li><p>operation<br>
assignment and copying: 주소를 공유 or 값만 복사</p> <ul><li>comparison</li> <li>catenation</li> <li>substring</li> <li>pattern matching(Perl)</li></ul></li> <li><p>C, C++ Not primitive<br>
Library of function<br>
E.g) char str[] = &quot;apples&quot;;<br>
strcpy(dest, src)  만약 primitive라면 자동으로 사이즈가 늘어나서 복사된다.</p></li> <li><p>Java primitive<br>
Perl, JavaScript, Ruby, and PHP<br>
pattern matching에 정규표현(regular expressions) 사용한다.<br>
E.g <code>/[A-Za-z][A-Za-z\d]+/</code><br>
E.g <code>/\d+\.?\d*|\.\d+/</code><br> <code>+</code> : 1개 이상 나옴<br> <code>*</code> : 0개 이상 나옴<br> <code>?</code> : optional<br> <code>\.</code> : 숫자 .<br> <code>|</code> : or</p></li> <li><p>Length option<br>
static or dynamic</p> <ul><li>static 속도↑ 편의성↑
COBOL, Java's String class<br>
Compile-time descriptor가 필요하다.</li> <li>Limited Dynamic Length<br>
C and C-style C++<br>
\0을 주는 것보다 길이를 크게 할당<br>
run-time descriptor가 필요 할 수 있으나 static과 비슷해서 필요 없을 때가 많다.</li> <li>Dynamic (no maximum)   속도↓ 공간↓
SNOBOL4, Perl, JavaScript, standard C++ library<br>
run-time descriptor가 필요하다.<br>
할당과 해제에 큰 구현문제가 있다.</li></ul></li></ul> <h3 id="enumeration-type"><a href="#enumeration-type" class="header-anchor">#</a> Enumeration type</h3> <p>C#의 enum</p> <p>Design issues<br>
enum 이름이 겹치는 경우</p> <p>장점 : 가독성 증가, 신뢰성 증가(컴파일러 체크 가능, 연산 불가)</p> <p>Reliability vs Writeability</p> <div class="language- extra-class"><pre class="language-text"><code>1) Reliability
days nextDay(days d) {
    int i = d;
    i++;
    if(i == 7) i = 0;
    return (days)i;
}

2) Writeability
days nextDay(days d) {
    if (d == mon)
        return tue;
    else if(d == tue)
        return wed;
        ...
}
</code></pre></div><p><code>1)</code>(정수로 변환이 가능한 경우)과 같이 코딩하면 유저가 실수 할 수 있다. 코드가 쉬워지며 가독성이 떨어진다.<br> <code>2)</code>(변환 불가)은 코딩이 길어지고 실수가 적어진다.</p> <h3 id="array-types"><a href="#array-types" class="header-anchor">#</a> Array Types</h3> <p><strong>homogeneous aggregate(같은 종류의 집합체)</strong> of data elements</p> <p>C 계열, Java에서는 배열과 원소의 자료형은 같아야한다.<br>
하지만, Javascript, Python, Ruby에서는 typeless reference라는 자료형을 넣게되면 다른 자료형의 포인터를 가질 수 있다.</p> <ul><li><p>indexing (subscripting)<br>
인덱스를 넣으면 해당 원소를 매핑해준다.<br>
Fortran과 Ada는 () 사용 (함수 사용과 혼동 가능)<br>
나머지는 [] 사용<br>
index와 element 자료형이 다를 수 있다.<br>
do not specify range checking :<br>
C, C++ Perl, and Fortan 속도↑<br>
Perl은 array는 <code>@</code>을 붙여서 선언, <code>$</code>을 붙이고 인덱싱하여 접근<br>
인덱싱값이 음수인 경우에는 오른쪽 끝에서 절댓값만큼 인덱싱하면 된다. 그리고 배열에 값이 없을 때 <code>undef</code>을 참조시키며 오류를 보고하지 않는다.</p></li> <li><p>Static array<br>
장점 : 효율성<br>
단점 : 메모리</p></li> <li><p>Fixed stack-dynamic array<br>
단점 : 속도(할당 &amp; 해지)</p></li> <li><p>Fixed heap-dynamic array<br>
장점 : 유연성</p></li> <li><p>Heap-dynamic array (subscript range가 dynamic하다)<br>
장점 : 유연성<br>
단점 : 속도(할당 &amp; 해지)<br>
Fixed는 생성시에 사이즈가 고정된다. Heap-dynamic을 제외하고 나머지 3가지는 subscript range가 스토리지에 할당 이후 lifetime 내내 바운딩 되어있다.</p></li> <li><p>Array categories<br>
JavaScript 배열은 연속적이지 않아도 된다. C언어를 예를 들면 배열이 연속적이여야 하나, JavaScript같은 경우에는 0~9, 50 총 배열의 길이는 11이나, 인덱싱이 자유롭다. 인덱스가 없는 곳을 참조할 경우 <code>undefined</code>가 반환된다.<br>
Python, Ruby, Lua는 배열끼리 붙이거나 원소를 집어 넣을 때만 배열 크기가 증가한다.</p></li> <li><p>Array Initialization<br>
C, C++, C#, Java는</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>int list [] = {4, 5, 7, 83};
</code></pre></div><p>배열의 길이를 컴파일러가 계산해준다.<br>
C와 C++은
문자형 배열 즉 문자열도</p> <div class="language- extra-class"><pre class="language-text"><code>char name [] = &quot;freddie&quot;;
</code></pre></div><p>자동으로 크기를 8을 할당해준다. (null-character)</p> <div class="language- extra-class"><pre class="language-text"><code>char *name [] = {&quot;Bob&quot;, &quot;Jake&quot;, &quot;Joe&quot;};
</code></pre></div><p>Java는 String을 기본 타입으로 인정하기 때문에</p> <div class="language- extra-class"><pre class="language-text"><code>String* [] names = {&quot;Bob&quot;, &quot;Jake&quot;, &quot;Joe&quot;};
</code></pre></div><p>로 해야한다.</p> <ul><li><p>Operations<br>
대부분 할당, 비교, 배열끼리 붙이기, slice을 제공하지만 C언어는 아무것도 제공하지 않는다.</p></li> <li><p>다차원 배열의 모양</p> <ul><li>Rectangular : row와 column의 수가 같다.(C#)<br>
E.g <code>myArray[3,7]</code></li> <li>Jagged : row와 column의 수가 다르다. (C, C++, C#, JAVA)<br>
E.g <code>myArray[3][4]</code>  배열의 배열로 정의</li></ul></li> <li><p>Slice<br>
새로운 자료형이 아닌 정의된 배열의 부분배열이다.<br>
ex) Python</p> <div class="language- extra-class"><pre class="language-text"><code>vector = [2, 4, 6, 8, 10, 12, 14, 16]
mat = [ [1,2,3], [4,5,6], [7,8,9] ]
</code></pre></div><p>vector[3:6]이라고 작성 인덱스 3부터 6번 이전까지 즉, [3,6)과 같은 개념이다. C++ string 라이브러리의 substr와 비슷하다.<br>
mat[1] =&gt; [4,5,6]<br>
mat[0][0:2] =&gt; [1,2]<br>
vector[0:7:2] =&gt; [2,6,10,14]<br>
이차원 배열인 경우는 해당 row을 반환하거나 row가 지정된 경우엔 column을 반환하면 된다.<br>
마지막 slice는 인덱스 0부터 시작해서 인덱스 7까지 idx+=2 해서 반환한다.</p></li> <li><p>배열들의 주소 찾기<br>
1차원 배열인 경우<br>
address(list[k]) = address (list[lower_bound]) + ((k-lower_bound) * element_size)<br>
2차원 배열인 경우<br>
Location (a[i,j]) = address of a [row_lb,col_lb] + (((i - row_lb) * n) + (j -col_lb)) * element_size</p> <ul><li>Row major<br>
Row 부터 채워감 (대부분의 언어)</li> <li>Column major<br>
Column부터 채워감 (FORTRAN)</li></ul></li> <li><p>Associative Arrays (Dictional)<br>
순서가 없는 집합, 인덱싱을 key-value로 되는 배열</p></li></ul> <p>ex) Perl<br>
array <code>@</code>로 선언 <code>$</code>로 접근<br>
Associative Array <code>%</code>로 선언 <code>$</code>로 접근<br>
e.g) %hi_temps = (&quot;Mon&quot; =&gt; 77, &quot;Tue&quot; =&gt; 79, &quot;Wed&quot; =&gt; 65, ...);
$hi_temps{&quot;Wed&quot;} = 83;
delete $hi_temps{&quot;Tue&quot;};</p> <h3 id="record-types"><a href="#record-types" class="header-anchor">#</a> Record Types</h3> <p><strong>heterogeneous aggregate(다른 종류의 집합체)</strong><br>
C언어에서 Struct<br>
배열에서는 인덱스를 숫자로했지만 레코드에서는 이름으로 접근한다.</p> <p>레코드에서 dot(.)을 이용해서 접근한다.</p> <h3 id="tuple-types"><a href="#tuple-types" class="header-anchor">#</a> Tuple Types</h3> <p>레코드와 비슷하나, 이름을 사용하지 않고 배열과 같이 순서대로 인덱싱한다.</p> <p>함수가 여러 값을 반환할 때 사용하기 좋다.</p> <p>ex) Python<br>
myTuple = (3, 5.8, 'apple')<br>
string과 같이 +으로 다른 튜플끼리 붙일 수 있다.</p> <p>ML<br>
var myTuple = (3, 5.8, 'apple');</p> <p>#1(myTuple)로 첫번째 원소에 접근 할 수 있다. 그리고 새로운 튜플타입을 선언할 수 있다.<br>
type intReal = int * real;</p> <p>F#<br>
let tup = (3, 5, 7)<br>
let a, b, c = tup</p> <p>Tuple이 없는 C언어</p> <div class="language- extra-class"><pre class="language-text"><code>1)
typedef struct _TwoValue {
    int intVal;
    float floatVal;
} TWO_VALUE;

TWO_VALUE f() {
    TWO_VALUE v;
    
    return v;
}
int main() {
    TWO_VALUE t;
    ...
    t = f();
}

2)
void f(int *ip, float *fp) {
    ...

    *ip = 3;
    *fp = 1.2f;
}
int main() {
    int i;
    float f;

    f(&amp;i,&amp;f);
}

// Tuple을 지원하는 C언어

tuple f() {
    ...
    return (3, 1.2f);
}
int main() {
    tuple t;
    ...
    t=f();
}
</code></pre></div><p>Tuple을 지원하지 않는다면 상당히 번거로워지고 C언어에서는 여러 반환값을 포인터를 이용해서 처리하고 있다. 하지만 가독성이 안 좋아서 Tuple을 사용할 수 있다면 좋다.</p> <h3 id="list-types"><a href="#list-types" class="header-anchor">#</a> List Types</h3> <p>LISP와 Scheme<br> <code>,</code>가 없이 사용한다.<br>
(A B C D) (A (B C) D)<br>
함수를 호출하는 경우와 똑같기 때문에 	`(A B C D) 구분한다.</p> <p>Operation
Car List 첫번째 원소<br>
Cdr List 첫번째 원소 제외한 원소들<br>
Cons List끼리 통합한다.</p> <p>ML<br>
Cons을 <code>::</code>로 대체해서 사용한다.<br>
3 :: [5, 7, 9] == Cons `3, (5, 7, 9)<br>
CAR과 CDR이 hd와 tl로 대체</p> <p>F# ≒ ML</p> <p>Python<br>
원소들의 타입이 달라도 된다.<br>
myList = [3, 5.8, &quot;grape&quot;]<br> <code>x = myList[1]</code> x = 5.8<br> <code>del myList[1]</code> 가능하며 이후에는 인덱스가 하나씩 땅겨짐</p> <p><strong>Comprehensions</strong><br>
[x * x for x in range(6) if x % 3 == 0]<br>
range(6) creates [0, 1, 2, 3, 4, 5, 6]<br>
∴ 나오는 리스트는 [0, 9, 36] x = 0 3 6</p> <h3 id="unions-types"><a href="#unions-types" class="header-anchor">#</a> Unions Types</h3> <p>여러개의 타입이 하나의 공간을 공유하는 형태<br>
공간은 개체중에서 가장 큰 사이즈가 해당 Union의 공간이다.<br>
메모리가 부족할 때는 많이 사용했으나, 지금은 많이 사용하지 않는다.</p> <p>Discriminated<br>
Type을 명시해서 사용하는 Union (Ada)<br>
Free Union<br>
Type checking을 하지않는 Union (C, C++, FORTRAN)</p> <div class="language- extra-class"><pre class="language-text"><code>Ada Union
type Shape (Circle, Triangle, Rectangle);
type Colors is (Red, Green, Blue);
type Figure (Form: Shape) is record
    Filed: Boolean;
    Color: Colors;
    case Form is
        when Circle =&gt; Diameter: Float;
        when Triangle =&gt; Leftsid, Rightside: Integer;
        Angle: Float;
        when Rectangle =&gt; Side1, Side2: Integer;
    end case;
end record;
</code></pre></div><p>각각의 상황에 따라 메모리가 할당되는게 다르다.</p> <p>Java나 C#에서는 union을 지원하지 않는다.<br>
Free union은 안전하지 않지만 빠르다. (자료형검사 X)
Ada의 Descriminated union은 안전하지만 속도가 느리다.</p> <h3 id="pointer-and-reference-types"><a href="#pointer-and-reference-types" class="header-anchor">#</a> Pointer and Reference Types</h3> <p>Pointer랑 달리 Reference는 초기화가 필요하다.</p> <ul><li>Pointer Operation</li></ul> <ol><li>assignment(할당)</li> <li>dereference(역참조 : 값 읽어오기)</li></ol> <p>dereference는 implicit(묵시적), explicit(명시적) 가능함</p> <div class="language- extra-class"><pre class="language-text"><code>int a = 10;
int *p;
int &amp;b = a;

p = &amp;a;
a = 20;
printf(&quot;%d&quot;,b); // 묵시적
printf(&quot;%d&quot;,*p); // 명시적
</code></pre></div><ul><li>Problems<br> <strong>Dangling pointers</strong> (dangerous)</li></ul> <div class="language- extra-class"><pre class="language-text"><code>char *p;
p = (char *)malloc(100);
...
free(p);
...
*p = 'a'; // p is a dangling pointer
</code></pre></div><p>Lost heap-dynamic variable (memory leakage problem, dangling object, garbage)</p> <div class="language- extra-class"><pre class="language-text"><code>void f() {
    char *p =(char *)malloc(100)  
    ...
    /p's content is lost!
}
</code></pre></div><p>Ada<br>
dangling pointer을 없애기 위해서 scope에 끝에서 자동으로 메모리를 해지한다. 하지만 메모리 누수는 일어날 수 있다.</p> <p>C, C++<br>
포인터 연산이 가능하다. *(p+i) == p[i]<br>
void * 포인터는 다른 타입의 포인터도 받을 수 있다.</p> <div class="language- extra-class"><pre class="language-text"><code>int a = 10;
void *p = &amp;a;
*p; // error;
* (int*)p; // ok;
</code></pre></div><p>Reference Types<br>
C++ Reference는 수정이 불가능하다.<br>
Java의 Reference는 수정이 가능하다.<br>
C#은 C++와 Java 두개 다 제공.</p> <p><strong>Dangling Pointer Problem Solution</strong></p> <ol><li>Tombstone<br>
Tombstone : heap-dynamic variable<br>
묘비 메모리 해지시 nil값으로 유지
메모리↑ 시간↑</li> <li>Lock-and-keys<br>
Head-dynamic variable으로, Lock과 key가 같아야 접근이 가능하다.<br>
메모리↑ 시간↑</li></ol> <h3 id="heap-management"><a href="#heap-management" class="header-anchor">#</a> Heap Management</h3> <p>매우 복잡한 런타임 프로세스이다.<br>
Single-size cells vs variable-size cells (고정 vs 가변)<br>
single-size cell은 간단하지만 variable-size cell은 복잡해진다.</p> <p>garbage 정리 방법</p> <ol><li><strong>Reference counters</strong> (eager approach)<br>
counter을 garbage들을 갯수만큼 유지한다. 꾸준히 정리한다.<br>
장점 : 지연이 없어 다른 방법들 보다 속도가 좋다.
단점 : 공간 낭비, counter 늘리고 줄이는 시간 필요</li> <li>Mark-sweep (lazy approach)<br>
마킹이 안된 것들을 한번에 정리<br>
메모리가 부족할 시에 Garbage Collection이 일어나고 root로 부터 dfs로 marking을 한다. Mark Phase가 끝나면 marking이 안된 것들을 해지하는 Sweep Phase가 일어난다.<br>
이 때, 프로그램 작동이 멈춘 다음 끝나고 작동이 재개한다.<br>
단점 : 지연 존재</li></ol> <h2 id="type-checking"><a href="#type-checking" class="header-anchor">#</a> Type Checking</h2> <p>Compatible Type<br> <code>void f(float b) {}</code><br> <code>f(3);</code><br> <code>3 + 1.2</code><br>
컴파일러에서 자동으로 변환 시켜주는 것을 <code>coercion</code>이라고 한다. 안되면 프로그래머가 직접 형변환을 해줘야한다.<br>
Type Checking이 강하면 type error가 없지만 프로그래머의 부담이 늘어난다.<br>
이 전부 static하다면 type checking도 static하다.<br>
같은 말로 피연산자들이 전부 dynamic하다면 type checking도 dynamic하다.<br> <strong>strongly typed</strong><br>
프로그래밍언어가 strongly typed하면 컴파일 이후엔 type error가 없다. 예로는 ML과 Ada이다.<br>
다른 언어를 살펴보면 C와 C++은 Strong Type이 아니다. 매개변수 type check도 안하거나 union은 type check을 안한다.<br>
Coercion이 강해질수록 strong typing이 약화되므로 서로 상충관계로 있다.<br>
Name Type Equivalence : 구조가 같아도 이름이 다르다면 할당이 안된다. 이름이 같아야지 할당이 가능하다.<br>
구현은 쉬우나, 제약이 많다.<br>
Structure Type Equivalence : 이름이 다르더라도 구조가 같으면 할당이 가능하다.<br>
유연하게 프로그래밍이 가능하나 구현이 어렵다.</p> <h3 id="요약"><a href="#요약" class="header-anchor">#</a> 요약</h3> <p>이름이 같으나 필드가 다를 때 같은 구조인가?<br>
인덱스가 다르나 길이가 같은 배열이 같은 배열인가?<br>
같은 구조와 같은 이름이지만 단위가 다른 경우 같은 구조인가?<br>
구현이 애매하다는 이유다.</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/TIL/assets/js/app.023881f9.js" defer></script><script src="/TIL/assets/js/2.5e371023.js" defer></script><script src="/TIL/assets/js/17.f2f7033c.js" defer></script>
  </body>
</html>
