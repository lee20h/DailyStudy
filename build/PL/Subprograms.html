<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Subprograms | Today 20h Learned</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="Today I Learned">
    <link rel="preload" href="/TIL/assets/css/0.styles.f9c21fbc.css" as="style"><link rel="preload" href="/TIL/assets/js/app.023881f9.js" as="script"><link rel="preload" href="/TIL/assets/js/2.5e371023.js" as="script"><link rel="preload" href="/TIL/assets/js/24.5a632101.js" as="script"><link rel="prefetch" href="/TIL/assets/js/10.3f780f5d.js"><link rel="prefetch" href="/TIL/assets/js/11.61deb296.js"><link rel="prefetch" href="/TIL/assets/js/12.8f5792e9.js"><link rel="prefetch" href="/TIL/assets/js/13.a4d8b86d.js"><link rel="prefetch" href="/TIL/assets/js/14.3141b341.js"><link rel="prefetch" href="/TIL/assets/js/15.456c9aa4.js"><link rel="prefetch" href="/TIL/assets/js/16.d15408d0.js"><link rel="prefetch" href="/TIL/assets/js/17.f2f7033c.js"><link rel="prefetch" href="/TIL/assets/js/18.d3ca7e9c.js"><link rel="prefetch" href="/TIL/assets/js/19.3460a969.js"><link rel="prefetch" href="/TIL/assets/js/20.e048387d.js"><link rel="prefetch" href="/TIL/assets/js/21.fe90ea5a.js"><link rel="prefetch" href="/TIL/assets/js/22.4d2c2356.js"><link rel="prefetch" href="/TIL/assets/js/23.a9257da5.js"><link rel="prefetch" href="/TIL/assets/js/25.0bda93d0.js"><link rel="prefetch" href="/TIL/assets/js/3.19c023e1.js"><link rel="prefetch" href="/TIL/assets/js/4.1d324b29.js"><link rel="prefetch" href="/TIL/assets/js/5.d60f48c3.js"><link rel="prefetch" href="/TIL/assets/js/6.4b5555ee.js"><link rel="prefetch" href="/TIL/assets/js/7.62d02473.js"><link rel="prefetch" href="/TIL/assets/js/8.64a73cfc.js"><link rel="prefetch" href="/TIL/assets/js/9.0a74ec9e.js">
    <link rel="stylesheet" href="/TIL/assets/css/0.styles.f9c21fbc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/TIL/" class="home-link router-link-active"><!----> <span class="site-name">Today 20h Learned</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/lee20h/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/lee20h/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Subprograms</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/TIL/PL/Subprograms.html#parameter" class="sidebar-link">Parameter</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TIL/PL/Subprograms.html#actual-formal-parameter-매핑방법" class="sidebar-link">Actual / Formal Parameter 매핑방법</a></li><li class="sidebar-sub-header"><a href="/TIL/PL/Subprograms.html#variable-numbers-of-parameters" class="sidebar-link">Variable numbers of parameters</a></li></ul></li><li><a href="/TIL/PL/Subprograms.html#parameter-passing" class="sidebar-link">Parameter Passing</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TIL/PL/Subprograms.html#구현" class="sidebar-link">구현</a></li><li class="sidebar-sub-header"><a href="/TIL/PL/Subprograms.html#pass-by-value" class="sidebar-link">Pass-by-Value</a></li><li class="sidebar-sub-header"><a href="/TIL/PL/Subprograms.html#pass-by-result" class="sidebar-link">Pass-by-Result</a></li><li class="sidebar-sub-header"><a href="/TIL/PL/Subprograms.html#pass-by-value-result" class="sidebar-link">Pass-by-Value-Result</a></li><li class="sidebar-sub-header"><a href="/TIL/PL/Subprograms.html#pass-by-reference" class="sidebar-link">Pass-by-Reference</a></li><li class="sidebar-sub-header"><a href="/TIL/PL/Subprograms.html#pass-by-name" class="sidebar-link">Pass-by-Name</a></li></ul></li><li><a href="/TIL/PL/Subprograms.html#매개변수-전달할-때-고려해야하는-점" class="sidebar-link">매개변수 전달할 때 고려해야하는 점</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TIL/PL/Subprograms.html#참조-환경" class="sidebar-link">참조 환경</a></li><li class="sidebar-sub-header"><a href="/TIL/PL/Subprograms.html#overloaded-subprogram" class="sidebar-link">overloaded subprogram</a></li></ul></li><li><a href="/TIL/PL/Subprograms.html#closure" class="sidebar-link">Closure</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/TIL/PL/Subprograms.html#coroutine" class="sidebar-link">Coroutine</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="subprograms"><a href="#subprograms" class="header-anchor">#</a> Subprograms</h1> <ol><li><strong>Procedure</strong> (리턴 X)</li> <li><strong>Function</strong> (리턴 O)</li></ol> <p>두개를 합쳐 Subprogram이라고 한다. 정의와 호출은 C언어와 같이 생각하면 된다.<br>
active란 호출이 되었으나 아직 끝까지 가지 않은 상태이다.<br>
header란 이름이라고 생각하면 된다. body는 실행할 형태를 정의한 것이다.</p> <h2 id="parameter"><a href="#parameter" class="header-anchor">#</a> Parameter</h2> <ol><li>Formal 정의시 적는 매개변수</li> <li>Actual 호출시 넘어가는 매개변수</li></ol> <p>Python에서는 같은 이름의 서로 다른 버전의 함수를 정의할 수 있다. def 함수가 실행전까지는 호출이 될 수 없어서 조건절로 나눠서 정의 후 다른 버젼의 함수를 호출 할 수 있다.</p> <h3 id="actual-formal-parameter-매핑방법"><a href="#actual-formal-parameter-매핑방법" class="header-anchor">#</a> <strong>Actual / Formal Parameter 매핑방법</strong></h3> <p>Positional (C언어)<br>
매개변수의 순서에 맞춰서 매핑을 하는 방법으로 안전하고 효과적이다고 볼 수 있다.</p> <p>Keyword<br> <code>f(a=1, b=2);</code><br>
이런식으로 사용하는 방법이다. 프로그래머가 함수가 정의된 부분을 다 알고 있어야한다. 순서가 바뀌어도 가능하다.</p> <p>Default Value<br>
C++ Python Ruby Ada PHP에서 Formal Parameter에 기본 값을 지정해줄 수 있다. 호출 시에 비어있으면 정의 해놓은 기본 값이 들어가고 매개변수를 넘긴다면 해당 값을 넣는다. C++에서는 Positional하게 매개변수를 매핑하기 때문에 매개변수에서 맨 오른쪽부터 기본 값을 줘야한다.</p> <h3 id="variable-numbers-of-parameters"><a href="#variable-numbers-of-parameters" class="header-anchor">#</a> <strong>Variable numbers of parameters</strong></h3> <p>인자의 갯수가 바뀔 수 있는 것을 가변인자라고 한다.<br>
예를들어 C언어에서의 printf을 살펴보면<br> <code>int printf(const char *fmt, ...); printf(&quot;%d&quot;,2); printf(&quot;%d%d&quot;,5,7);</code><br>
이 가변인자를 사용하려면 무조건 <strong>Positional한 언어</strong>여야만 가능하다. 위치를 사용해서 가변인자를 구현하기 때문이다.<br>
C#에서도 사용할 수 있다.</p> <div class="language- extra-class"><pre class="language-text"><code>public void DisplayList(params int[] list) {
	foreach (int next in list) {
		Console.WriteLine(&quot;Next value {0}&quot;, next);
	}
}
MyClass myObject = new MyClass;
int[] myList = new int[6] {2,4,6,8,10,12};
myObject.DisplayList(myList);
myObject.DisplayList(2, 4, 3 * x - 1, 17);
</code></pre></div><p>원래는 첫번째와 같이 actual parameter에는 int의 배열만 받을 수 있으나 params로 받게 되면 인자를 가변으로 다 받을 수 있다. 하지만 받는 인자들의 자료형은 꼭 동일해야한다. 이러한 함수 정의 방법으로 자유도가 증가한다.</p> <table><thead><tr><th style="text-align:left;">Memory</th></tr></thead> <tbody><tr><td style="text-align:left;">Code</td></tr> <tr><td style="text-align:left;">Data</td></tr> <tr><td style="text-align:left;">Heap</td></tr> <tr><td style="text-align:left;">Stack</td></tr></tbody></table> <p>위와 같이 메모리 구조를 가진다. 지역 변수는 stack-dynamic에 저장이 된다. 이러한 구조 때문에 재귀가 가능해진다. 그리고 밑에 쌓인 subprogram들의 공간을 공유해서 사용할 수 있다. 단점으로는 할당과 해지, 초기화 시간이 걸린다. 또한 스텍에서 해당 subprogram을 찾고 거기서 상대주소를 찾기 때문에 Indirect addressing라고 보면 된다. 그리고 이전에 있었던 일들을 기억하지 않는다. (history insensitive)</p> <h2 id="parameter-passing"><a href="#parameter-passing" class="header-anchor">#</a> <strong>Parameter Passing</strong></h2> <p>Semantics Model</p> <ol><li>In mode</li> <li>Out mode</li> <li>Inout mode</li></ol> <p>대부분은 명시해서 사용한다. int x out y inout z와 같이 명시한다. C언어에서는 In mode만 지원한다. 하지만 Pointer을 이용해서 극복한다.</p> <h3 id="구현"><a href="#구현" class="header-anchor">#</a> <strong>구현</strong></h3> <p>물리적으로 값을 옮기는 방법<br>
실질적 메모리에 적재된 값을 변경하는 방법</p> <ol><li>Pass-by-Value (In mode)</li> <li>Pass-by-Result (Out mode)</li> <li>Pass-by-Value-Result (Inout mode)</li> <li>Pass-by-Reference (Inout mode)</li> <li>Pass-by-Name (Inout mode)</li></ol> <h3 id="pass-by-value"><a href="#pass-by-value" class="header-anchor">#</a> Pass-by-Value</h3> <p>actual parameter의 값을 formal parameter에 초기화시켜준다.<br>
단점으로는 Formal Parameter 공간이 추가적으로 필요하다. 또한, 값만 복사해오기 때문에 Indirect addressing으로 두번 접근해서 속도가 떨어진다.</p> <h3 id="pass-by-result"><a href="#pass-by-result" class="header-anchor">#</a> Pass-by-Result</h3> <p>Formal Parameter가 지역변수처럼 사용된 다음 반환 될 때 Actual Parameter에 값이 반환된다. 이 방법 또한 추가적인 공간이 필요하다.<br>
잠재적 문제<br>
C#에서의 예</p> <div class="language- extra-class"><pre class="language-text"><code>void Fixer(out int x, out int y) {
	x = 17;
	y = 35;
}
...
f.Fixer(out a, out a);
</code></pre></div><p>이 때 변수 a의 값은 무엇일까?<br>
컴파일러마다 어떤 값을 넣는지는 다르다.<br>
다른 예시도 보자.</p> <div class="language- extra-class"><pre class="language-text"><code>void Doit(out int x, int idx) {
	x = 17;
	idx = 42;
}
...
sub = 21;
f.Doit(out list[sub], sub);
</code></pre></div><p>list[sub]에 참조할때 sub값이 어떻게 될까?<br>
함수를 호출하고 처음에는 sub이 21이였으나 끝날 때는 42로 바뀌게 된다.</p> <h3 id="pass-by-value-result"><a href="#pass-by-value-result" class="header-anchor">#</a> Pass-by-Value-Result</h3> <p>위의 두 방식을 합쳤다.</p> <h3 id="pass-by-reference"><a href="#pass-by-reference" class="header-anchor">#</a> Pass-by-Reference</h3> <p>Call-by-Reference와 같은 말로, 주소값을 전달하는 방식이다. 장점으로는 전달하는 과정이 효율적이다. 왜냐 값의 입장에서 보면 정수가 아닌 구조체인 경우 구조체를 그대로 복사할 때 크기가 크지만, 주소값을 전달하기 때문에 메모리를 아낄 수 있다. 단점으로는 Formal parameter에 접근하는 속도가 느리며 원치않은 Side effect와 aliase가 일어날 수 있다.<br>
원치않은 Aliase가 일어나면 가독성과 신뢰성에 큰 영향을 준다.</p> <h3 id="pass-by-name"><a href="#pass-by-name" class="header-anchor">#</a> Pass-by-Name</h3> <p>C의 MACRO정의 (#define)과 똑같다고 보면 된다.</p> <div class="language- extra-class"><pre class="language-text"><code>#define swap(t,a,b) {t = a; a = b; b = t;}
int temp = 0, value7 = 10, value9 = 20;
swap(temp,value7,value9);
</code></pre></div><p>자유도가 증가하며 <strong>Textual substitution</strong>가 일어난다.</p> <p>C와 C++에서 다차원 배열을 Formal Parameter로 받아야하는 경우 <code>void f(int v[][10])</code>이런 식으로 뒤에 사이즈를 명시해야 stack에서 배열 크기만큼 할당할 수 있다.<br>
해결법으로 배열의 주소값과 차원별로 사이즈를 보내주는 방식으로 할 수 있다.</p> <div class="language- extra-class"><pre class="language-text"><code>void f(int **v, int xsize, int ysize) { }
</code></pre></div><p>Java와 C#인 경우에는 배열자체가 객체로 보기 때문에 객체를 그냥 적어주기만 하면 call-by-reference로 넘어가게 된다. length을 가지고 사이즈를 해결할 수 있다. 속도는 느리지만 프로그래머가 유연하게 코딩이 가능하다.</p> <h2 id="매개변수-전달할-때-고려해야하는-점"><a href="#매개변수-전달할-때-고려해야하는-점" class="header-anchor">#</a> 매개변수 전달할 때 고려해야하는 점</h2> <ol><li>Efficiency</li> <li>One-way or two-way data transfer</li></ol> <p>One-way란 in 혹은 out mode만 가능하며 Two-way는 inout mode을 뜻한다. 1과 2는 서로 반비례하므로 잘 선택해야한다.</p> <p>매개변수로 함수의 이름을 넣는 함수 (high-order-function)<br>
ex) <code>void g(); int k(); f(g()); f(k())</code></p> <h3 id="참조-환경"><a href="#참조-환경" class="header-anchor">#</a> 참조 환경</h3> <p>참조 환경에 따라서 함수에서 어떤 변수를 참조하는게 달라진다. 그 방법에 대해 설명해보자.</p> <ol><li><strong>Shallow binding</strong> (dynamic-scoped languages)</li> <li><strong>Deep binding</strong>(static-scoped languages)</li> <li><strong>Ad hoc binding</strong> (그때 마다 다르며 자신을 call한 환경의 변수를 참조)</li></ol> <p>ex)</p> <div class="language- extra-class"><pre class="language-text"><code>function sub1() {
	var x;
	function sub2() {
		alert(x);
	};
	function sub3() {
		var x;
		x = 3;
		sub4(sub2);
	};
	function sub4(subx) {
		var x;
		x = 4;
		subx();
	};	
	x = 1;
	sub3();
}
</code></pre></div><p>Shallow binding : sub4'x<br>
Deep binding : sub1'x<br>
Ad hoc binding : sub3'x</p> <p>Indirect call<br>
C와 C++에서는 함수 포인터를 이용해서 구현한다.<br>
C#에서는 delegate을 사용한다.</p> <div class="language- extra-class"><pre class="language-text"><code>public delegate int Change(int x);
static int fun1 (int x) {}
Change chgfun1 = new Change(fun1);
chgfun1 += fun2;
chgfun1(12);
</code></pre></div><p>delegate에 동일한 타입의 함수포인터 여러 개를 담은 뒤 한번에 실행할 수 있다.</p> <h3 id="overloaded-subprogram"><a href="#overloaded-subprogram" class="header-anchor">#</a> overloaded subprogram</h3> <p>이름이 같고 다른 subprogram이다. ad hoc polymorphism이라고도 한다.<br>
e.g <code>void f(); void f(int a); void (int a, int b)</code></p> <p>Generic Subprogram<br>
Generic 혹은 Polymorphic subprogram 이라고 한다.<br>
C++에서는 template을 가지고 구현한다.</p> <div class="language- extra-class"><pre class="language-text"><code>template &lt;class Type&gt; Type max(Type first, Type second) {
	return first &gt; second ? first : second;
}
</code></pre></div><p>Subprogram이 모든 타입을 받아서 사용되는게 아니라 자료형 별로 여러가지 버젼의 subprogram이 생성이 된다.</p> <p>User-defined overloaded Operator<br>
Python example</p> <div class="language- extra-class"><pre class="language-text"><code>def __add__ (self, second) :
	return Complex(self.real + second.real, self.imag + second.imag)
</code></pre></div><p>이렇게 정의해서 사용해도 좋지만 <code>x + y</code>로 표현한다면 가독성이 좋아진다.</p> <h2 id="closure"><a href="#closure" class="header-anchor">#</a> <strong>Closure</strong></h2> <p>subprogram과 referencing environment를 합친 것을 Closure이라고 한다.<br>
Closure을 데이터처럼 사용할려면 함수에서 Closure을 반환하면 사용할 수 있다.<br>
JavaScript에서의 Closure는</p> <div class="language- extra-class"><pre class="language-text"><code>function makeAdder(x) {
	return funtion(y) {return x + y;}
}
...
var add10 = makeAdder(10); // 함수
var add5 = makeAdder(5); // 함수
document.write(&quot;add 10 to 20: &quot; + add10(20) + &quot;&lt;br /&gt;&quot;);
document.write(&quot;add 5 to 20: &quot; + add5(20) + &quot;&lt;br /&gt;&quot;);
</code></pre></div><p>Closure는 anonymous function이라고 할 수 있는데 이게 곧 referencing environment이다.<br>
C#에서는 delegate을 이용해서 closure을 만든다.<br> <code>Func&lt;int, int&gt; // &lt;input, output&gt;</code></p> <div class="language- extra-class"><pre class="language-text"><code>static Func&lt;int, int&gt; makeAdder(int x) {
	return delegate (int y) {return x + y;};
}
</code></pre></div><p>Func문법 빼고는 JavaScript와 같다고 보면 된다.</p> <h2 id="coroutine"><a href="#coroutine" class="header-anchor">#</a> <strong>Coroutine</strong></h2> <p>Caller와 Callee가 있을 때 subprogram은 호출 후 Callee가 끝나야 반환이 된다. 하지만 Coroutine에서는 Caller와 Callee가 서로 같은 프로그램을 완성한다. Coroutine Call 대신에 <code>resume</code>이라는 이름을 쓴다. 이러한 이름이 붙여진 이유가 재호출 시에 이전 호출에서 멈춘 시점부터 다시 시작하기 때문이다.<br>
Quasi-concurrent execution이라며 동시실행한다고 보기도 한다.</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/TIL/assets/js/app.023881f9.js" defer></script><script src="/TIL/assets/js/2.5e371023.js" defer></script><script src="/TIL/assets/js/24.5a632101.js" defer></script>
  </body>
</html>
