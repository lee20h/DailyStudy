{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{363:function(t,a,e){\"use strict\";e.r(a);var n=e(42),i=Object(n.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[e(\"h1\",{attrs:{id:\"implementing-subprograms\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#implementing-subprograms\"}},[t._v(\"#\")]),t._v(\" Implementing Subprograms\")]),t._v(\" \"),e(\"p\",[t._v(\"Call을 하게 되면 context switch에서 PCB에 저장해서 다시 복원하듯이 런타임 스택에 저장(push) 후 끝나면 다음 주소값으로 return(pop)하게 된다.\")]),t._v(\" \"),e(\"h2\",{attrs:{id:\"simple-subprogram\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#simple-subprogram\"}},[t._v(\"#\")]),t._v(\" Simple Subprogram\")]),t._v(\" \"),e(\"p\",[t._v(\"Local 변수가 없고, nested가 없는 Subprogram이다.\")]),t._v(\" \"),e(\"h3\",{attrs:{id:\"call-sematics\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#call-sematics\"}},[t._v(\"#\")]),t._v(\" Call Sematics\")]),t._v(\" \"),e(\"ol\",[e(\"li\",[t._v(\"현재 실행상태를 스택에 저장\")]),t._v(\" \"),e(\"li\",[t._v(\"매개변수 전달\")]),t._v(\" \"),e(\"li\",[t._v(\"리턴값을 전달\")]),t._v(\" \"),e(\"li\",[t._v(\"이동\")])]),t._v(\" \"),e(\"h3\",{attrs:{id:\"return-sematics\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#return-sematics\"}},[t._v(\"#\")]),t._v(\" Return Sematics\")]),t._v(\" \"),e(\"ol\",[e(\"li\",[t._v(\"Out mode라면 현재의 값을 actual parameter로 복사\")]),t._v(\" \"),e(\"li\",[t._v(\"리턴이 함수라면 함수값이 리턴\")]),t._v(\" \"),e(\"li\",[t._v(\"스택에 저장된 실행상태 복원\")]),t._v(\" \"),e(\"li\",[t._v(\"이동\")])]),t._v(\" \"),e(\"p\",[t._v(\"필요한 저장소\"),e(\"br\"),t._v(\"\\n상태 정보, 매개변수, 리턴주소, 리턴 값이나 함수, 임시변수 - Stack에 저장. 따라서 재귀 가능\")]),t._v(\" \"),e(\"p\",[t._v(\"Actual code와 non-code(data) 두 파트로 나눠져있다. 여기서는 \"),e(\"strong\",[t._v(\"activation record\")]),t._v(\"(non-code)에 대해서만 주로 다룬다.\"),e(\"br\"),t._v(\"\\nActivation record instance call할때마다 stack에 쌓이게 된다.\")]),t._v(\" \"),e(\"table\",[e(\"thead\",[e(\"tr\",[e(\"th\",{staticStyle:{\"text-align\":\"left\"}},[t._v(\"Simple subprogram\")])])]),t._v(\" \"),e(\"tbody\",[e(\"tr\",[e(\"td\",{staticStyle:{\"text-align\":\"left\"}},[t._v(\"Local variables\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",{staticStyle:{\"text-align\":\"left\"}},[t._v(\"Parameters\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",{staticStyle:{\"text-align\":\"left\"}},[t._v(\"Return address\")])])])]),t._v(\" \"),e(\"p\",[t._v(\"이런 식으로 stack이 쌓인다.\")]),t._v(\" \"),e(\"table\",[e(\"thead\",[e(\"tr\",[e(\"th\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"Memory\")]),t._v(\" \"),e(\"th\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"Simple subprogram\")])])]),t._v(\" \"),e(\"tbody\",[e(\"tr\",[e(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"Code\")]),t._v(\" \"),e(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"Code\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"Data\")]),t._v(\" \"),e(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"Data\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"Heap\")]),t._v(\" \"),e(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"Data\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"Stack\")]),t._v(\" \"),e(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"Data\")])])])]),t._v(\" \"),e(\"h3\",{attrs:{id:\"typical-activation-record\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#typical-activation-record\"}},[t._v(\"#\")]),t._v(\" Typical Activation Record\")]),t._v(\" \"),e(\"table\",[e(\"thead\",[e(\"tr\",[e(\"th\",{staticStyle:{\"text-align\":\"left\"}},[t._v(\"Typical Activation Record\")])])]),t._v(\" \"),e(\"tbody\",[e(\"tr\",[e(\"td\",{staticStyle:{\"text-align\":\"left\"}},[t._v(\"Local variables\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",{staticStyle:{\"text-align\":\"left\"}},[t._v(\"Parameters\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",{staticStyle:{\"text-align\":\"left\"}},[e(\"strong\",[t._v(\"Dynamic link\")])])]),t._v(\" \"),e(\"tr\",[e(\"td\",{staticStyle:{\"text-align\":\"left\"}},[t._v(\"Return address\")])])])]),t._v(\" \"),e(\"p\",[t._v(\"Stack을 사용하는데에 있어 이전의 Stack의 Top의 위치를 저장할 필요가 있어서 Dynamic link에 저장한다.\")]),t._v(\" \"),e(\"p\",[t._v(\"Activation record 사이즈가 dynamic하다.\\nStack Pointer를 Environment Pointer라고도 한다.\")]),t._v(\" \"),e(\"p\",[t._v(\"지역변수 괄호로 표시\"),e(\"br\"),t._v(\"\\nmain(p) calls fun1\"),e(\"br\"),t._v(\"\\nfun1(s,t) calls fun2\"),e(\"br\"),t._v(\"\\nfun2(y) calls fun3\")]),t._v(\" \"),e(\"p\",[t._v(\"Dynamic Chain == Call Chain\"),e(\"br\"),t._v(\"\\ntop을 기준으로 상대주소로 찾아 지역변수에 접근 할 수 있다. 지역변수의 상대위치는 컴파일 타임에 컴파일러에 의해 정해진다.\")]),t._v(\" \"),e(\"h3\",{attrs:{id:\"재귀가-있을-때의-activation-record\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#재귀가-있을-때의-activation-record\"}},[t._v(\"#\")]),t._v(\" 재귀가 있을 때의 Activation record\")]),t._v(\" \"),e(\"table\",[e(\"thead\",[e(\"tr\",[e(\"th\",{staticStyle:{\"text-align\":\"left\"}},[t._v(\"Activation Record for factorial\")])])]),t._v(\" \"),e(\"tbody\",[e(\"tr\",[e(\"td\",{staticStyle:{\"text-align\":\"left\"}},[t._v(\"Functional value\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",{staticStyle:{\"text-align\":\"left\"}},[t._v(\"Parameters\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",{staticStyle:{\"text-align\":\"left\"}},[e(\"strong\",[t._v(\"Dynamic link\")])])]),t._v(\" \"),e(\"tr\",[e(\"td\",{staticStyle:{\"text-align\":\"left\"}},[t._v(\"Return address\")])])])]),t._v(\" \"),e(\"p\",[t._v(\"C언어는 Nested subprogram이 지원하지 않아서 이전까지의 설명으로 충분하지만 다른 언어(FORTAN 95+, Ada, Python, JavaScript, Ruby, Lua)에서는 허용되므로 봐보자.\"),e(\"br\"),t._v(\"\\n변수의 이름이 같은 경우 먼저 맞는 ARI를 찾고 ARI에서의 Offset을 찾아야한다.\"),e(\"br\"),t._v(\"\\nStatic-scope일 때는 이미 정해져있기 때문에 offset을 찾기 쉽다. 맞는 ARI를 찾기 위해서 Static-Scope에서 정한 방법은 Static link를 ARI에 가지고 부모 함수의 Top에 연결해준다. Static_depth가 the depth of nesting이다.\"),e(\"br\"),t._v(\"\\nChain_offset or nesting_depth란 static_link을 몇번 따라갔는가이다. pair로 정의하면 (chain_offset, local_offset)으로 정의하면 된다.\")]),t._v(\" \"),e(\"p\",[t._v(\"Ada의 예시\")]),t._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[t._v(\"procedure Main_2 is\\n  X : Integer;\\n  procedure Bigsub is\\n    A, B, C : Integer;\\n    procedure Sub1 is\\n      A, D : Integer;\\n      begin -- of Sub1\\n      A := B + C;  <-----------------------1\\n    end;  -- of Sub1\\n    procedure Sub2(X : Integer) is\\n      B, E : Integer;\\n      procedure Sub3 is\\n        C, E : Integer;\\n        begin -- of Sub3\\n        Sub1;\\n        E := B + A:   <--------------------2\\n        end; -- of Sub3\\n      begin -- of Sub2\\n      Sub3;\\n      A := D + E;  <-----------------------3\\n      end; -- of Sub2 }\\n    begin -- of Bigsub\\n    Sub2(7);\\n    end; -- of Bigsub\\n  begin\\n  Bigsub;\\nend; of Main_2 }\\n\")])])]),e(\"p\",[t._v(\"Call sequence for Main_2\"),e(\"br\"),t._v(\"\\nMain_2 calls Bigsub\"),e(\"br\"),t._v(\"\\nBigsub calls Sub2\"),e(\"br\"),t._v(\"\\nSub2 calls Sub3\"),e(\"br\"),t._v(\"\\nSub3 calls Sub1\"),e(\"br\"),t._v(\"\\n이러한 순서로 이뤄져 있다.\")]),t._v(\" \"),e(\"p\",[t._v(\"지금까지 했던 내용에서 추가해야할 내용은 \"),e(\"strong\",[t._v(\"Static Link\")]),t._v(\"의 경우 자기를 감싸는 함수(ancestor)의 ARI의 시작부분을 가르켜야한다.\")]),t._v(\" \"),e(\"h2\",{attrs:{id:\"static-scoping\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#static-scoping\"}},[t._v(\"#\")]),t._v(\" Static Scoping\")]),t._v(\" \"),e(\"p\",[t._v(\"dynamic link는 전에 스택의 top pointer\"),e(\"br\"),t._v(\"\\nstatic link는 가장 가까운 static parent의 ARI의 시작부분이다.\")]),t._v(\" \"),e(\"p\",[t._v(\"static parent을 찾는 두가지의 방법\")]),t._v(\" \"),e(\"ol\",[e(\"li\",[t._v(\"dynamic chain으로 전부 찾아보기\")]),t._v(\" \"),e(\"li\",[t._v(\"static depth을 이미 컴파일 타임에 알기 때문에 그 차이를 가지고 구한다.\")])]),t._v(\" \"),e(\"p\",[t._v(\"Static chain의 문제점\"),e(\"br\"),t._v(\"\\nnon-local 변수에 대해 접근할려고 할 때 속도가 느려질 수 있다. 따라서 C언어에서는 non-local 변수는 글로벌 변수만 허용하며, nesting을 허용하지 않아서 속도를 저하시킬 요인을 없앴다.\")]),t._v(\" \"),e(\"p\",[t._v(\"Block\"),e(\"br\"),t._v(\"\\nexample C\")]),t._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[t._v(\"void f() {\\n\\t{int temp;\\n\\ttemp = list[upper];\\n\\tlist[upper]\\n = list[lower];\\n\\tlist[lower] = temp;\\n\\t}\\t\\n}\\n\\n\")])])]),e(\"p\",[t._v(\"stack에 block을 더 쌓게 된다. 가독성은 증가할 수 있으나 실행속도에서는 저하한다. (컴파일러가 똑똑하면 가려줘서 해결이 되기도 함)\")]),t._v(\" \"),e(\"h2\",{attrs:{id:\"dynamic-scoping\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#dynamic-scoping\"}},[t._v(\"#\")]),t._v(\" Dynamic Scoping\")]),t._v(\" \"),e(\"p\",[t._v(\"Dynamic Scoping을 지원하는 프로그래밍 언어일 때 static link는 필요없다.\"),e(\"br\"),t._v(\"\\n이 때 구현 방법 2가지\")]),t._v(\" \"),e(\"ol\",[e(\"li\",[t._v(\"Deep Access : dynamic chain을 통해서 직접 검색함. 따라서 모든 ARI에 변수 이름을 저장할 공간을 가지고 있어야한다. 검색 시간도 오래걸린다 (worst : 전부 다 찾음)\")]),t._v(\" \"),e(\"li\",[t._v(\"Shallow Access : 변수 마다 스택을 만들어서 쓰이는 함수들을 하나씩 쌓아놓는다. 스택의 탑에 위치한 함수가 현재 쓰이는 위치이다.\")])])])}),[],!1,null,null,null);a.default=i.exports}}]);","extractedComments":[]}