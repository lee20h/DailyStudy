{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{358:function(t,e,r){\"use strict\";r.r(e);var s=r(42),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[r(\"h1\",{attrs:{id:\"연속합\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#연속합\"}},[t._v(\"#\")]),t._v(\" 연속합\")]),t._v(\" \"),r(\"p\",[r(\"a\",{attrs:{href:\"https://cses.fi/problemset/task/1643\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"CSES\"),r(\"OutboundLink\")],1),t._v(\" \"),r(\"a\",{attrs:{href:\"https://www.acmicpc.net/problem/1912\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"BOJ\"),r(\"OutboundLink\")],1),t._v(\" \"),r(\"a\",{attrs:{href:\"https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXQm2SqdxkDFAUo&categoryId=AWXQm2SqdxkDFAUo&categoryType=CODE&&&\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"SWEA\"),r(\"OutboundLink\")],1)]),t._v(\" \"),r(\"h2\",{attrs:{id:\"초기-생각\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#초기-생각\"}},[t._v(\"#\")]),t._v(\" 초기 생각\")]),t._v(\" \"),r(\"p\",[t._v(\"기본적으로 비슷한 문제로 처음에 떠올린 방법은 시간 복잡도 O(n)을 가졌다. 하지만 시간초과로 제대로 해결하지 못하였는데 이 부분은 O(1)로 구현해야했다. 그래서 밑과 같은 방식으로 복습하여 구현하였다.\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"알고리즘\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#알고리즘\"}},[t._v(\"#\")]),t._v(\" 알고리즘\")]),t._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[t._v(\"int best = v[0], sum = 0; // best인 값은 초기에 첫번째 배열로 설정하고 합은 0으로 설정한다.\\nfor (int i=0; i<n; i++) {\\n\\tif(sum + v[i] < v[i]) sum = v[i]; // if(sum < 0)과 동일 sum이 0보다 작으면 v[i]로 새롭게 초기화시켜준다.\\n\\telse sum += v[i]; // sum이 양수거나 0과 같다면 sum에 현재 인덱스부분을 더해준다.\\n\\tbest = max(best,sum); // best는 best와 sum중 큰 값으로 갱신해준다.\\n}\\n\")])])]),r(\"p\",[t._v(\"와 같은 알고리즘으로 구현하게 되면 연속적인 값들의 합을 구할 때 시간복잡도 O(1)로 구할 수 있다.\")])])}),[],!1,null,null,null);e.default=a.exports}}]);","extractedComments":[]}