{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{367:function(t,n,a){\"use strict\";a.r(n);var e=a(42),i=Object(e.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"수분할\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#수분할\"}},[t._v(\"#\")]),t._v(\" 수분할\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"수분할\")]),t._v(\"은 자연수 n을 순서에 상관 없이 하나 이상의 자연수의 합으로 나타내는 방법이다. 그 중 일반적인 방법으로는 n/m 수분할이다. 이 방법은 n을 m이하의 자연수로만 나타내는 방법이다.\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"예시\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#예시\"}},[t._v(\"#\")]),t._v(\" 예시\")]),t._v(\" \"),a(\"p\",[t._v(\"예를 들어  5/2 수분할은\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"1+1+1+1+1  \\n2+1+1+1  \\n2+2+1  \\n\")])])]),a(\"p\",[t._v(\"이렇게 된다. 이러한 n/m 수분할은 재귀적으로 생각할 수 있는데, 재귀적으로 생각하게 된다면 5/2 수분할에서 \"),a(\"code\",[t._v(\"1+\")]),t._v(\" 와 \"),a(\"code\",[t._v(\"2+\")]),t._v(\"로 시작하는 부분 두 가지로 나눌 수 있다.\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"1) 1로 시작   \\n1+1+1+1+1\\n\\n2) 2로 시작\\n2+1+1+1  \\n2+2+1  \\n\")])])]),a(\"p\",[a(\"code\",[t._v(\"1+\")]),t._v(\" 뒤에 나오는 \"),a(\"code\",[t._v(\"1+1+1+1\")]),t._v(\"은 4/1 수분할과 같고, \"),a(\"code\",[t._v(\"2+\")]),t._v(\"뒤에 나오는 \"),a(\"code\",[t._v(\"1+1+1, 2+1\")]),t._v(\"은 3/2 수분할의 두가지 이다. 따라서 이끌어낼 수 있는 점화식은 아래와 같다.\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"partition(0,m) = 1\\nif n>0 then, partition(n,m) = ∑(i=1 ~ m) partition(n-i,i)\\n\")])])]),a(\"h2\",{attrs:{id:\"소스코드\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#소스코드\"}},[t._v(\"#\")]),t._v(\" 소스코드\")]),t._v(\" \"),a(\"p\",[t._v(\"이러한 내용을 토대로 C언어로 함수를 작성하면,\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"int partition(int n, int m) {\\n\\tint cnt = 0, i;\\n\\tif (n < m) m=n;\\n\\tif (n == 0) return 1;\\n\\tfor (i=1; i<=m; i++)\\n\\t\\tcnt += partition(n-i, i);\\n\\treturn cnt;\\n}\\n\")])])]),a(\"p\",[t._v(\"이러한 함수가 만들어진다. 하지만 중복계산이 계속 생겨서 효율적이지 못한 코드가 된다. 이 함수를 메모이제이션을 이용해서 바꾸어보자.\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"#define MAX 200\\nint memo[MAX][MAX];\\nint partition(int n, int m) {\\n\\tint cnt = 0, i;\\n\\tif (n < m) m=n;\\n\\tif (memo[n][m] > 0) return memo[n][m];\\n\\tif (n == 0) return memo[n][m] = 1;\\n\\tfor (i=1; i<=m; i++)\\n\\t\\tcnt += partition(n-i, i);\\n\\treturn memo[n][m] = cnt;\\n}\\n\")])])]),a(\"p\",[t._v(\"memo 배열에서 값이 0이라면 값이 계산된 적이 없기에 함수를 실행하고 그외의 다른 값이라면 도중에 해당 memo값을 반환해준다. 이러한 호출 구조는 그대로이며, 조금만 추가하면 중복 계산을 없앨 수 있다.\")]),t._v(\" \"),a(\"p\",[t._v(\"수분할에 덧셈의 순서를 구분하게 되는 코드도 가볍게 보았다.\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"int partition2(int n) {\\n\\tint cnt = 0, i;\\n\\tfor (i=1; i<n; i++)\\n\\t\\tcnt += partition2(n-i);\\n\\treturn cnt + 1;\\n}\\n\")])])])])}),[],!1,null,null,null);n.default=i.exports}}]);","extractedComments":[]}