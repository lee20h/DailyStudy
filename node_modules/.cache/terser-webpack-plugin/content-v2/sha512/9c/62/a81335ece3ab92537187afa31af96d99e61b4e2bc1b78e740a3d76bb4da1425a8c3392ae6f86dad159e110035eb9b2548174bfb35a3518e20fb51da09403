{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{374:function(e,n,r){\"use strict\";r.r(n);var a=r(42),t=Object(a.a)({},(function(){var e=this,n=e.$createElement,r=e._self._c||n;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[r(\"h1\",{attrs:{id:\"data-types\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#data-types\"}},[e._v(\"#\")]),e._v(\" Data Types\")]),e._v(\" \"),r(\"ol\",[r(\"li\",[r(\"strong\",[e._v(\"표현\")])]),e._v(\" \"),r(\"li\",[r(\"strong\",[e._v(\"연산\")])])]),e._v(\" \"),r(\"p\",[e._v(\"자료형은 2가지를 고려해야한다. 이 부분을 생각하면서 공부하자\")]),e._v(\" \"),r(\"p\",[e._v(\"Data type : 데이터의 모음과 미리 정의된 연산들의 모음\")]),e._v(\" \"),r(\"p\",[e._v(\"descriptor : 변수의 속성들의 모음\"),r(\"br\"),e._v(\"\\n모든 속성들은 정적이라서 컴파일 시간까지만 필요하다.(Symbol table에 유지) 따라서 런타임에는 value만 유지한다.\")]),e._v(\" \"),r(\"p\",[e._v(\"object : 상속을 제외한 추상 데이터\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"primitive-data-types\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#primitive-data-types\"}},[e._v(\"#\")]),e._v(\" Primitive data types\")]),e._v(\" \"),r(\"p\",[e._v(\"가장 기본적인 data type\"),r(\"br\"),e._v(\"\\n비트마다 하드웨어에 기반해서 data type을 정함\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"numeric-types\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#numeric-types\"}},[e._v(\"#\")]),e._v(\" Numeric types\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[r(\"p\",[e._v(\"integer\"),r(\"br\"),e._v(\"\\n음의 정수 표현\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"Sign-magnitude notation (MSB가 부호비트)\"),r(\"br\"),e._v(\"\\n산술문제가 존재 (0011 (3) + 1011 (-3) ≠ 0)\")]),e._v(\" \"),r(\"li\",[e._v(\"Two's complement notation\"),r(\"br\"),e._v(\"\\n보수 취하고 1을 더함\"),r(\"br\"),e._v(\"\\n대부분 사용함\")]),e._v(\" \"),r(\"li\",[e._v(\"One's complement notation\"),r(\"br\"),e._v(\"\\n0을 표현하는 방법이 2가지가 있음 (1111, 0000)\")])])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"floating point\"),r(\"br\"),e._v(\"\\n표현방법\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"Fixed-point notation\"),r(\"br\"),e._v(\"\\n1.3\"),r(\"br\"),e._v(\"\\n0001 | 0011\"),r(\"br\"),e._v(\"\\n0.03 같은 숫자 표현 불가\")]),e._v(\" \"),r(\"li\",[e._v(\"Floating-point notation\"),r(\"br\"),e._v(\"\\n0.13 x 10¹\"),r(\"br\"),e._v(\"\\n0111 | 0001\"),r(\"br\"),e._v(\"\\n이러한 원리로 작동한다.\"),r(\"br\"),e._v(\"\\n0.03 = 0.3 x 10^(-1)도 같이 표현할 수 있다.\")])])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"complex\"),r(\"br\"),e._v(\"\\nreal + imaginary\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"decimal\"),r(\"br\"),e._v(\"\\nC언어에서 제공 X\"),r(\"br\"),e._v(\"\\n은행에서 많이 사용함 (COBOL)\"),r(\"br\"),e._v(\"\\nBCD : 0,1로 코딩된 십진법을 사용함\"),r(\"br\"),e._v(\"\\n4bit or 8bit 사용\"),r(\"br\"),e._v(\"\\nex) 123\"),r(\"br\"),e._v(\"\\n4 bit : 0001 0010 0011\"),r(\"br\"),e._v(\"\\n8 bit : 00000001 00000010 00000011\"),r(\"br\"),e._v(\"\\n장점 : 정확성\"),r(\"br\"),e._v(\"\\n단점 : 범위 한계, 메모리 낭비\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"boolean\"),r(\"br\"),e._v(\"\\ntrue or false\"),r(\"br\"),e._v(\"\\nbyte 단위로 표현 (bit로 하면 연산시 복잡함)\"),r(\"br\"),e._v(\"\\n장점 : 가독성\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"character\"),r(\"br\"),e._v(\"\\n숫자 -> 문자 매핑\\nASCII 이용\"),r(\"br\"),e._v(\"\\n영어 외의 언어 Unicode\")])])]),e._v(\" \"),r(\"h2\",{attrs:{id:\"structured-data-types\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#structured-data-types\"}},[e._v(\"#\")]),e._v(\" Structured data types\")]),e._v(\" \"),r(\"p\",[e._v(\"primitive data type들을 구조화 시킨 data type\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"string\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#string\"}},[e._v(\"#\")]),e._v(\" string\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[r(\"p\",[e._v(\"issue\"),r(\"br\"),e._v(\"\\nprimitive로 볼지, char형의 배열로 볼지\"),r(\"br\"),e._v(\"\\nstring의 길이를 정적으로 할지 동적으로 할지 (hi -> hello, hello -> hi)\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"operation\"),r(\"br\"),e._v(\"\\nassignment and copying: 주소를 공유 or 값만 복사\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"comparison\")]),e._v(\" \"),r(\"li\",[e._v(\"catenation\")]),e._v(\" \"),r(\"li\",[e._v(\"substring\")]),e._v(\" \"),r(\"li\",[e._v(\"pattern matching(Perl)\")])])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"C, C++ Not primitive\"),r(\"br\"),e._v(\"\\nLibrary of function\"),r(\"br\"),e._v('\\nE.g) char str[] = \"apples\";'),r(\"br\"),e._v(\"\\nstrcpy(dest, src)  만약 primitive라면 자동으로 사이즈가 늘어나서 복사된다.\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"Java primitive\"),r(\"br\"),e._v(\"\\nPerl, JavaScript, Ruby, and PHP\"),r(\"br\"),e._v(\"\\npattern matching에 정규표현(regular expressions) 사용한다.\"),r(\"br\"),e._v(\"\\nE.g \"),r(\"code\",[e._v(\"/[A-Za-z][A-Za-z\\\\d]+/\")]),r(\"br\"),e._v(\"\\nE.g \"),r(\"code\",[e._v(\"/\\\\d+\\\\.?\\\\d*|\\\\.\\\\d+/\")]),r(\"br\"),e._v(\" \"),r(\"code\",[e._v(\"+\")]),e._v(\" : 1개 이상 나옴\"),r(\"br\"),e._v(\" \"),r(\"code\",[e._v(\"*\")]),e._v(\" : 0개 이상 나옴\"),r(\"br\"),e._v(\" \"),r(\"code\",[e._v(\"?\")]),e._v(\" : optional\"),r(\"br\"),e._v(\" \"),r(\"code\",[e._v(\"\\\\.\")]),e._v(\" : 숫자 .\"),r(\"br\"),e._v(\" \"),r(\"code\",[e._v(\"|\")]),e._v(\" : or\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"Length option\"),r(\"br\"),e._v(\"\\nstatic or dynamic\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"static 속도↑ 편의성↑\\nCOBOL, Java's String class\"),r(\"br\"),e._v(\"\\nCompile-time descriptor가 필요하다.\")]),e._v(\" \"),r(\"li\",[e._v(\"Limited Dynamic Length\"),r(\"br\"),e._v(\"\\nC and C-style C++\"),r(\"br\"),e._v(\"\\n\\\\0을 주는 것보다 길이를 크게 할당\"),r(\"br\"),e._v(\"\\nrun-time descriptor가 필요 할 수 있으나 static과 비슷해서 필요 없을 때가 많다.\")]),e._v(\" \"),r(\"li\",[e._v(\"Dynamic (no maximum)   속도↓ 공간↓\\nSNOBOL4, Perl, JavaScript, standard C++ library\"),r(\"br\"),e._v(\"\\nrun-time descriptor가 필요하다.\"),r(\"br\"),e._v(\"\\n할당과 해제에 큰 구현문제가 있다.\")])])])]),e._v(\" \"),r(\"h3\",{attrs:{id:\"enumeration-type\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#enumeration-type\"}},[e._v(\"#\")]),e._v(\" Enumeration type\")]),e._v(\" \"),r(\"p\",[e._v(\"C#의 enum\")]),e._v(\" \"),r(\"p\",[e._v(\"Design issues\"),r(\"br\"),e._v(\"\\nenum 이름이 겹치는 경우\")]),e._v(\" \"),r(\"p\",[e._v(\"장점 : 가독성 증가, 신뢰성 증가(컴파일러 체크 가능, 연산 불가)\")]),e._v(\" \"),r(\"p\",[e._v(\"Reliability vs Writeability\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"1) Reliability\\ndays nextDay(days d) {\\n    int i = d;\\n    i++;\\n    if(i == 7) i = 0;\\n    return (days)i;\\n}\\n\\n2) Writeability\\ndays nextDay(days d) {\\n    if (d == mon)\\n        return tue;\\n    else if(d == tue)\\n        return wed;\\n        ...\\n}\\n\")])])]),r(\"p\",[r(\"code\",[e._v(\"1)\")]),e._v(\"(정수로 변환이 가능한 경우)과 같이 코딩하면 유저가 실수 할 수 있다. 코드가 쉬워지며 가독성이 떨어진다.\"),r(\"br\"),e._v(\" \"),r(\"code\",[e._v(\"2)\")]),e._v(\"(변환 불가)은 코딩이 길어지고 실수가 적어진다.\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"array-types\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#array-types\"}},[e._v(\"#\")]),e._v(\" Array Types\")]),e._v(\" \"),r(\"p\",[r(\"strong\",[e._v(\"homogeneous aggregate(같은 종류의 집합체)\")]),e._v(\" of data elements\")]),e._v(\" \"),r(\"p\",[e._v(\"C 계열, Java에서는 배열과 원소의 자료형은 같아야한다.\"),r(\"br\"),e._v(\"\\n하지만, Javascript, Python, Ruby에서는 typeless reference라는 자료형을 넣게되면 다른 자료형의 포인터를 가질 수 있다.\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[r(\"p\",[e._v(\"indexing (subscripting)\"),r(\"br\"),e._v(\"\\n인덱스를 넣으면 해당 원소를 매핑해준다.\"),r(\"br\"),e._v(\"\\nFortran과 Ada는 () 사용 (함수 사용과 혼동 가능)\"),r(\"br\"),e._v(\"\\n나머지는 [] 사용\"),r(\"br\"),e._v(\"\\nindex와 element 자료형이 다를 수 있다.\"),r(\"br\"),e._v(\"\\ndo not specify range checking :\"),r(\"br\"),e._v(\"\\nC, C++ Perl, and Fortan 속도↑\"),r(\"br\"),e._v(\"\\nPerl은 array는 \"),r(\"code\",[e._v(\"@\")]),e._v(\"을 붙여서 선언, \"),r(\"code\",[e._v(\"$\")]),e._v(\"을 붙이고 인덱싱하여 접근\"),r(\"br\"),e._v(\"\\n인덱싱값이 음수인 경우에는 오른쪽 끝에서 절댓값만큼 인덱싱하면 된다. 그리고 배열에 값이 없을 때 \"),r(\"code\",[e._v(\"undef\")]),e._v(\"을 참조시키며 오류를 보고하지 않는다.\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"Static array\"),r(\"br\"),e._v(\"\\n장점 : 효율성\"),r(\"br\"),e._v(\"\\n단점 : 메모리\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"Fixed stack-dynamic array\"),r(\"br\"),e._v(\"\\n단점 : 속도(할당 & 해지)\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"Fixed heap-dynamic array\"),r(\"br\"),e._v(\"\\n장점 : 유연성\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"Heap-dynamic array (subscript range가 dynamic하다)\"),r(\"br\"),e._v(\"\\n장점 : 유연성\"),r(\"br\"),e._v(\"\\n단점 : 속도(할당 & 해지)\"),r(\"br\"),e._v(\"\\nFixed는 생성시에 사이즈가 고정된다. Heap-dynamic을 제외하고 나머지 3가지는 subscript range가 스토리지에 할당 이후 lifetime 내내 바운딩 되어있다.\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"Array categories\"),r(\"br\"),e._v(\"\\nJavaScript 배열은 연속적이지 않아도 된다. C언어를 예를 들면 배열이 연속적이여야 하나, JavaScript같은 경우에는 0~9, 50 총 배열의 길이는 11이나, 인덱싱이 자유롭다. 인덱스가 없는 곳을 참조할 경우 \"),r(\"code\",[e._v(\"undefined\")]),e._v(\"가 반환된다.\"),r(\"br\"),e._v(\"\\nPython, Ruby, Lua는 배열끼리 붙이거나 원소를 집어 넣을 때만 배열 크기가 증가한다.\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"Array Initialization\"),r(\"br\"),e._v(\"\\nC, C++, C#, Java는\")])])]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"int list [] = {4, 5, 7, 83};\\n\")])])]),r(\"p\",[e._v(\"배열의 길이를 컴파일러가 계산해준다.\"),r(\"br\"),e._v(\"\\nC와 C++은\\n문자형 배열 즉 문자열도\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v('char name [] = \"freddie\";\\n')])])]),r(\"p\",[e._v(\"자동으로 크기를 8을 할당해준다. (null-character)\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v('char *name [] = {\"Bob\", \"Jake\", \"Joe\"};\\n')])])]),r(\"p\",[e._v(\"Java는 String을 기본 타입으로 인정하기 때문에\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v('String* [] names = {\"Bob\", \"Jake\", \"Joe\"};\\n')])])]),r(\"p\",[e._v(\"로 해야한다.\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[r(\"p\",[e._v(\"Operations\"),r(\"br\"),e._v(\"\\n대부분 할당, 비교, 배열끼리 붙이기, slice을 제공하지만 C언어는 아무것도 제공하지 않는다.\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"다차원 배열의 모양\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"Rectangular : row와 column의 수가 같다.(C#)\"),r(\"br\"),e._v(\"\\nE.g \"),r(\"code\",[e._v(\"myArray[3,7]\")])]),e._v(\" \"),r(\"li\",[e._v(\"Jagged : row와 column의 수가 다르다. (C, C++, C#, JAVA)\"),r(\"br\"),e._v(\"\\nE.g \"),r(\"code\",[e._v(\"myArray[3][4]\")]),e._v(\"  배열의 배열로 정의\")])])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"Slice\"),r(\"br\"),e._v(\"\\n새로운 자료형이 아닌 정의된 배열의 부분배열이다.\"),r(\"br\"),e._v(\"\\nex) Python\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"vector = [2, 4, 6, 8, 10, 12, 14, 16]\\nmat = [ [1,2,3], [4,5,6], [7,8,9] ]\\n\")])])]),r(\"p\",[e._v(\"vector[3:6]이라고 작성 인덱스 3부터 6번 이전까지 즉, [3,6)과 같은 개념이다. C++ string 라이브러리의 substr와 비슷하다.\"),r(\"br\"),e._v(\"\\nmat[1] => [4,5,6]\"),r(\"br\"),e._v(\"\\nmat[0][0:2] => [1,2]\"),r(\"br\"),e._v(\"\\nvector[0:7:2] => [2,6,10,14]\"),r(\"br\"),e._v(\"\\n이차원 배열인 경우는 해당 row을 반환하거나 row가 지정된 경우엔 column을 반환하면 된다.\"),r(\"br\"),e._v(\"\\n마지막 slice는 인덱스 0부터 시작해서 인덱스 7까지 idx+=2 해서 반환한다.\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"배열들의 주소 찾기\"),r(\"br\"),e._v(\"\\n1차원 배열인 경우\"),r(\"br\"),e._v(\"\\naddress(list[k]) = address (list[lower_bound]) + ((k-lower_bound) * element_size)\"),r(\"br\"),e._v(\"\\n2차원 배열인 경우\"),r(\"br\"),e._v(\"\\nLocation (a[i,j]) = address of a [row_lb,col_lb] + (((i - row_lb) * n) + (j -col_lb)) * element_size\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"Row major\"),r(\"br\"),e._v(\"\\nRow 부터 채워감 (대부분의 언어)\")]),e._v(\" \"),r(\"li\",[e._v(\"Column major\"),r(\"br\"),e._v(\"\\nColumn부터 채워감 (FORTRAN)\")])])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"Associative Arrays (Dictional)\"),r(\"br\"),e._v(\"\\n순서가 없는 집합, 인덱싱을 key-value로 되는 배열\")])])]),e._v(\" \"),r(\"p\",[e._v(\"ex) Perl\"),r(\"br\"),e._v(\"\\narray \"),r(\"code\",[e._v(\"@\")]),e._v(\"로 선언 \"),r(\"code\",[e._v(\"$\")]),e._v(\"로 접근\"),r(\"br\"),e._v(\"\\nAssociative Array \"),r(\"code\",[e._v(\"%\")]),e._v(\"로 선언 \"),r(\"code\",[e._v(\"$\")]),e._v(\"로 접근\"),r(\"br\"),e._v('\\ne.g) %hi_temps = (\"Mon\" => 77, \"Tue\" => 79, \"Wed\" => 65, ...);\\n$hi_temps{\"Wed\"} = 83;\\ndelete $hi_temps{\"Tue\"};')]),e._v(\" \"),r(\"h3\",{attrs:{id:\"record-types\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#record-types\"}},[e._v(\"#\")]),e._v(\" Record Types\")]),e._v(\" \"),r(\"p\",[r(\"strong\",[e._v(\"heterogeneous aggregate(다른 종류의 집합체)\")]),r(\"br\"),e._v(\"\\nC언어에서 Struct\"),r(\"br\"),e._v(\"\\n배열에서는 인덱스를 숫자로했지만 레코드에서는 이름으로 접근한다.\")]),e._v(\" \"),r(\"p\",[e._v(\"레코드에서 dot(.)을 이용해서 접근한다.\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"tuple-types\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#tuple-types\"}},[e._v(\"#\")]),e._v(\" Tuple Types\")]),e._v(\" \"),r(\"p\",[e._v(\"레코드와 비슷하나, 이름을 사용하지 않고 배열과 같이 순서대로 인덱싱한다.\")]),e._v(\" \"),r(\"p\",[e._v(\"함수가 여러 값을 반환할 때 사용하기 좋다.\")]),e._v(\" \"),r(\"p\",[e._v(\"ex) Python\"),r(\"br\"),e._v(\"\\nmyTuple = (3, 5.8, 'apple')\"),r(\"br\"),e._v(\"\\nstring과 같이 +으로 다른 튜플끼리 붙일 수 있다.\")]),e._v(\" \"),r(\"p\",[e._v(\"ML\"),r(\"br\"),e._v(\"\\nvar myTuple = (3, 5.8, 'apple');\")]),e._v(\" \"),r(\"p\",[e._v(\"#1(myTuple)로 첫번째 원소에 접근 할 수 있다. 그리고 새로운 튜플타입을 선언할 수 있다.\"),r(\"br\"),e._v(\"\\ntype intReal = int * real;\")]),e._v(\" \"),r(\"p\",[e._v(\"F#\"),r(\"br\"),e._v(\"\\nlet tup = (3, 5, 7)\"),r(\"br\"),e._v(\"\\nlet a, b, c = tup\")]),e._v(\" \"),r(\"p\",[e._v(\"Tuple이 없는 C언어\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"1)\\ntypedef struct _TwoValue {\\n    int intVal;\\n    float floatVal;\\n} TWO_VALUE;\\n\\nTWO_VALUE f() {\\n    TWO_VALUE v;\\n    \\n    return v;\\n}\\nint main() {\\n    TWO_VALUE t;\\n    ...\\n    t = f();\\n}\\n\\n2)\\nvoid f(int *ip, float *fp) {\\n    ...\\n\\n    *ip = 3;\\n    *fp = 1.2f;\\n}\\nint main() {\\n    int i;\\n    float f;\\n\\n    f(&i,&f);\\n}\\n\\n// Tuple을 지원하는 C언어\\n\\ntuple f() {\\n    ...\\n    return (3, 1.2f);\\n}\\nint main() {\\n    tuple t;\\n    ...\\n    t=f();\\n}\\n\")])])]),r(\"p\",[e._v(\"Tuple을 지원하지 않는다면 상당히 번거로워지고 C언어에서는 여러 반환값을 포인터를 이용해서 처리하고 있다. 하지만 가독성이 안 좋아서 Tuple을 사용할 수 있다면 좋다.\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"list-types\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#list-types\"}},[e._v(\"#\")]),e._v(\" List Types\")]),e._v(\" \"),r(\"p\",[e._v(\"LISP와 Scheme\"),r(\"br\"),e._v(\" \"),r(\"code\",[e._v(\",\")]),e._v(\"가 없이 사용한다.\"),r(\"br\"),e._v(\"\\n(A B C D) (A (B C) D)\"),r(\"br\"),e._v(\"\\n함수를 호출하는 경우와 똑같기 때문에 \\t`(A B C D) 구분한다.\")]),e._v(\" \"),r(\"p\",[e._v(\"Operation\\nCar List 첫번째 원소\"),r(\"br\"),e._v(\"\\nCdr List 첫번째 원소 제외한 원소들\"),r(\"br\"),e._v(\"\\nCons List끼리 통합한다.\")]),e._v(\" \"),r(\"p\",[e._v(\"ML\"),r(\"br\"),e._v(\"\\nCons을 \"),r(\"code\",[e._v(\"::\")]),e._v(\"로 대체해서 사용한다.\"),r(\"br\"),e._v(\"\\n3 :: [5, 7, 9] == Cons `3, (5, 7, 9)\"),r(\"br\"),e._v(\"\\nCAR과 CDR이 hd와 tl로 대체\")]),e._v(\" \"),r(\"p\",[e._v(\"F# ≒ ML\")]),e._v(\" \"),r(\"p\",[e._v(\"Python\"),r(\"br\"),e._v(\"\\n원소들의 타입이 달라도 된다.\"),r(\"br\"),e._v('\\nmyList = [3, 5.8, \"grape\"]'),r(\"br\"),e._v(\" \"),r(\"code\",[e._v(\"x = myList[1]\")]),e._v(\" x = 5.8\"),r(\"br\"),e._v(\" \"),r(\"code\",[e._v(\"del myList[1]\")]),e._v(\" 가능하며 이후에는 인덱스가 하나씩 땅겨짐\")]),e._v(\" \"),r(\"p\",[r(\"strong\",[e._v(\"Comprehensions\")]),r(\"br\"),e._v(\"\\n[x * x for x in range(6) if x % 3 == 0]\"),r(\"br\"),e._v(\"\\nrange(6) creates [0, 1, 2, 3, 4, 5, 6]\"),r(\"br\"),e._v(\"\\n∴ 나오는 리스트는 [0, 9, 36] x = 0 3 6\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"unions-types\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#unions-types\"}},[e._v(\"#\")]),e._v(\" Unions Types\")]),e._v(\" \"),r(\"p\",[e._v(\"여러개의 타입이 하나의 공간을 공유하는 형태\"),r(\"br\"),e._v(\"\\n공간은 개체중에서 가장 큰 사이즈가 해당 Union의 공간이다.\"),r(\"br\"),e._v(\"\\n메모리가 부족할 때는 많이 사용했으나, 지금은 많이 사용하지 않는다.\")]),e._v(\" \"),r(\"p\",[e._v(\"Discriminated\"),r(\"br\"),e._v(\"\\nType을 명시해서 사용하는 Union (Ada)\"),r(\"br\"),e._v(\"\\nFree Union\"),r(\"br\"),e._v(\"\\nType checking을 하지않는 Union (C, C++, FORTRAN)\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"Ada Union\\ntype Shape (Circle, Triangle, Rectangle);\\ntype Colors is (Red, Green, Blue);\\ntype Figure (Form: Shape) is record\\n    Filed: Boolean;\\n    Color: Colors;\\n    case Form is\\n        when Circle => Diameter: Float;\\n        when Triangle => Leftsid, Rightside: Integer;\\n        Angle: Float;\\n        when Rectangle => Side1, Side2: Integer;\\n    end case;\\nend record;\\n\")])])]),r(\"p\",[e._v(\"각각의 상황에 따라 메모리가 할당되는게 다르다.\")]),e._v(\" \"),r(\"p\",[e._v(\"Java나 C#에서는 union을 지원하지 않는다.\"),r(\"br\"),e._v(\"\\nFree union은 안전하지 않지만 빠르다. (자료형검사 X)\\nAda의 Descriminated union은 안전하지만 속도가 느리다.\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"pointer-and-reference-types\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#pointer-and-reference-types\"}},[e._v(\"#\")]),e._v(\" Pointer and Reference Types\")]),e._v(\" \"),r(\"p\",[e._v(\"Pointer랑 달리 Reference는 초기화가 필요하다.\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"Pointer Operation\")])]),e._v(\" \"),r(\"ol\",[r(\"li\",[e._v(\"assignment(할당)\")]),e._v(\" \"),r(\"li\",[e._v(\"dereference(역참조 : 값 읽어오기)\")])]),e._v(\" \"),r(\"p\",[e._v(\"dereference는 implicit(묵시적), explicit(명시적) 가능함\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v('int a = 10;\\nint *p;\\nint &b = a;\\n\\np = &a;\\na = 20;\\nprintf(\"%d\",b); // 묵시적\\nprintf(\"%d\",*p); // 명시적\\n')])])]),r(\"ul\",[r(\"li\",[e._v(\"Problems\"),r(\"br\"),e._v(\" \"),r(\"strong\",[e._v(\"Dangling pointers\")]),e._v(\" (dangerous)\")])]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"char *p;\\np = (char *)malloc(100);\\n...\\nfree(p);\\n...\\n*p = 'a'; // p is a dangling pointer\\n\")])])]),r(\"p\",[e._v(\"Lost heap-dynamic variable (memory leakage problem, dangling object, garbage)\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"void f() {\\n    char *p =(char *)malloc(100)  \\n    ...\\n    /p's content is lost!\\n}\\n\")])])]),r(\"p\",[e._v(\"Ada\"),r(\"br\"),e._v(\"\\ndangling pointer을 없애기 위해서 scope에 끝에서 자동으로 메모리를 해지한다. 하지만 메모리 누수는 일어날 수 있다.\")]),e._v(\" \"),r(\"p\",[e._v(\"C, C++\"),r(\"br\"),e._v(\"\\n포인터 연산이 가능하다. *(p+i) == p[i]\"),r(\"br\"),e._v(\"\\nvoid * 포인터는 다른 타입의 포인터도 받을 수 있다.\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"int a = 10;\\nvoid *p = &a;\\n*p; // error;\\n* (int*)p; // ok;\\n\")])])]),r(\"p\",[e._v(\"Reference Types\"),r(\"br\"),e._v(\"\\nC++ Reference는 수정이 불가능하다.\"),r(\"br\"),e._v(\"\\nJava의 Reference는 수정이 가능하다.\"),r(\"br\"),e._v(\"\\nC#은 C++와 Java 두개 다 제공.\")]),e._v(\" \"),r(\"p\",[r(\"strong\",[e._v(\"Dangling Pointer Problem Solution\")])]),e._v(\" \"),r(\"ol\",[r(\"li\",[e._v(\"Tombstone\"),r(\"br\"),e._v(\"\\nTombstone : heap-dynamic variable\"),r(\"br\"),e._v(\"\\n묘비 메모리 해지시 nil값으로 유지\\n메모리↑ 시간↑\")]),e._v(\" \"),r(\"li\",[e._v(\"Lock-and-keys\"),r(\"br\"),e._v(\"\\nHead-dynamic variable으로, Lock과 key가 같아야 접근이 가능하다.\"),r(\"br\"),e._v(\"\\n메모리↑ 시간↑\")])]),e._v(\" \"),r(\"h3\",{attrs:{id:\"heap-management\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#heap-management\"}},[e._v(\"#\")]),e._v(\" Heap Management\")]),e._v(\" \"),r(\"p\",[e._v(\"매우 복잡한 런타임 프로세스이다.\"),r(\"br\"),e._v(\"\\nSingle-size cells vs variable-size cells (고정 vs 가변)\"),r(\"br\"),e._v(\"\\nsingle-size cell은 간단하지만 variable-size cell은 복잡해진다.\")]),e._v(\" \"),r(\"p\",[e._v(\"garbage 정리 방법\")]),e._v(\" \"),r(\"ol\",[r(\"li\",[r(\"strong\",[e._v(\"Reference counters\")]),e._v(\" (eager approach)\"),r(\"br\"),e._v(\"\\ncounter을 garbage들을 갯수만큼 유지한다. 꾸준히 정리한다.\"),r(\"br\"),e._v(\"\\n장점 : 지연이 없어 다른 방법들 보다 속도가 좋다.\\n단점 : 공간 낭비, counter 늘리고 줄이는 시간 필요\")]),e._v(\" \"),r(\"li\",[e._v(\"Mark-sweep (lazy approach)\"),r(\"br\"),e._v(\"\\n마킹이 안된 것들을 한번에 정리\"),r(\"br\"),e._v(\"\\n메모리가 부족할 시에 Garbage Collection이 일어나고 root로 부터 dfs로 marking을 한다. Mark Phase가 끝나면 marking이 안된 것들을 해지하는 Sweep Phase가 일어난다.\"),r(\"br\"),e._v(\"\\n이 때, 프로그램 작동이 멈춘 다음 끝나고 작동이 재개한다.\"),r(\"br\"),e._v(\"\\n단점 : 지연 존재\")])]),e._v(\" \"),r(\"h2\",{attrs:{id:\"type-checking\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#type-checking\"}},[e._v(\"#\")]),e._v(\" Type Checking\")]),e._v(\" \"),r(\"p\",[e._v(\"Compatible Type\"),r(\"br\"),e._v(\" \"),r(\"code\",[e._v(\"void f(float b) {}\")]),r(\"br\"),e._v(\" \"),r(\"code\",[e._v(\"f(3);\")]),r(\"br\"),e._v(\" \"),r(\"code\",[e._v(\"3 + 1.2\")]),r(\"br\"),e._v(\"\\n컴파일러에서 자동으로 변환 시켜주는 것을 \"),r(\"code\",[e._v(\"coercion\")]),e._v(\"이라고 한다. 안되면 프로그래머가 직접 형변환을 해줘야한다.\"),r(\"br\"),e._v(\"\\nType Checking이 강하면 type error가 없지만 프로그래머의 부담이 늘어난다.\"),r(\"br\"),e._v(\"\\n이 전부 static하다면 type checking도 static하다.\"),r(\"br\"),e._v(\"\\n같은 말로 피연산자들이 전부 dynamic하다면 type checking도 dynamic하다.\"),r(\"br\"),e._v(\" \"),r(\"strong\",[e._v(\"strongly typed\")]),r(\"br\"),e._v(\"\\n프로그래밍언어가 strongly typed하면 컴파일 이후엔 type error가 없다. 예로는 ML과 Ada이다.\"),r(\"br\"),e._v(\"\\n다른 언어를 살펴보면 C와 C++은 Strong Type이 아니다. 매개변수 type check도 안하거나 union은 type check을 안한다.\"),r(\"br\"),e._v(\"\\nCoercion이 강해질수록 strong typing이 약화되므로 서로 상충관계로 있다.\"),r(\"br\"),e._v(\"\\nName Type Equivalence : 구조가 같아도 이름이 다르다면 할당이 안된다. 이름이 같아야지 할당이 가능하다.\"),r(\"br\"),e._v(\"\\n구현은 쉬우나, 제약이 많다.\"),r(\"br\"),e._v(\"\\nStructure Type Equivalence : 이름이 다르더라도 구조가 같으면 할당이 가능하다.\"),r(\"br\"),e._v(\"\\n유연하게 프로그래밍이 가능하나 구현이 어렵다.\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"요약\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#요약\"}},[e._v(\"#\")]),e._v(\" 요약\")]),e._v(\" \"),r(\"p\",[e._v(\"이름이 같으나 필드가 다를 때 같은 구조인가?\"),r(\"br\"),e._v(\"\\n인덱스가 다르나 길이가 같은 배열이 같은 배열인가?\"),r(\"br\"),e._v(\"\\n같은 구조와 같은 이름이지만 단위가 다른 경우 같은 구조인가?\"),r(\"br\"),e._v(\"\\n구현이 애매하다는 이유다.\")])])}),[],!1,null,null,null);n.default=t.exports}}]);","extractedComments":[]}