{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{361:function(e,a,t){\"use strict\";t.r(a);var n=t(42),r=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"expressions-and-assignment-statements\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#expressions-and-assignment-statements\"}},[e._v(\"#\")]),e._v(\" Expressions and Assignment Statements\")]),e._v(\" \"),t(\"p\",[e._v(\"들어가기 앞서, 명령형 언어는 assignment가 제일 중요하다. 하지만 이로인해 Side effect가 발생한다.\")]),e._v(\" \"),t(\"h2\",{attrs:{id:\"side-effect\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#side-effect\"}},[e._v(\"#\")]),e._v(\" Side Effect\")]),e._v(\" \"),t(\"p\",[t(\"strong\",[e._v(\"Side effect\")]),e._v(\"란 함수가 자신이 선언된 범위 밖의 변수의 값을 변경시키는 것.\"),t(\"br\"),e._v(\"\\nex)\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"int gCount;\\nint square(int a) {\\n\\tgCount++;\\n\\treturn a*a;\\n}\\n\")])])]),t(\"p\",[e._v(\"함수형 언어는 Side effect가 없다. 왜냐 \"),t(\"strong\",[e._v(\"assignment\")]),e._v(\"가 없기 때문이다.\")]),e._v(\" \"),t(\"h2\",{attrs:{id:\"arithmetic-expression\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#arithmetic-expression\"}},[e._v(\"#\")]),e._v(\" Arithmetic Expression\")]),e._v(\" \"),t(\"p\",[e._v(\"산술이 프로그래밍 언어 개발의 첫번째 동기라고 할 수 있다.\"),t(\"br\"),e._v(\"\\n연산자는 피연산자의 갯수로 분류할 수 있다.\")]),e._v(\" \"),t(\"ol\",[t(\"li\",[e._v(\"Unary : -a\")]),e._v(\" \"),t(\"li\",[e._v(\"Binary : a+b\")]),e._v(\" \"),t(\"li\",[e._v(\"Ternary : a>b?a:b\")])]),e._v(\" \"),t(\"p\",[e._v(\"위치에 따라 분류할 수도 있다.\")]),e._v(\" \"),t(\"ol\",[t(\"li\",[e._v(\"Prefix : 괄호 없이 산술이 가능하다.\")]),e._v(\" \"),t(\"li\",[e._v(\"Infix : 대부분 프로그래밍언어에서는 사람이 코딩하므로 infix을 주로 사용한다.\")]),e._v(\" \"),t(\"li\",[e._v(\"Postfix : stack이용하면 편하다.\")])]),e._v(\" \"),t(\"h2\",{attrs:{id:\"arithmetic-operator-evalation-order\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#arithmetic-operator-evalation-order\"}},[e._v(\"#\")]),e._v(\" Arithmetic Operator Evalation Order\")]),e._v(\" \"),t(\"ol\",[t(\"li\",[e._v(\"연산자 우선순위\")]),e._v(\" \"),t(\"li\",[e._v(\"associativity rule\")])]),e._v(\" \"),t(\"p\",[e._v(\"전형적인 우선순위는\\n괄호 -> unary operator -> 제곱 -> *,/ -> +,-이다.\"),t(\"br\"),e._v(\"\\n보통 왼쪽에서 오른쪽으로 진행되나 제곱은 오른쪽에서 왼쪽으로 진행하면 된다.\"),t(\"br\"),e._v(\"\\n우선순위를 잘 모르겠으면 괄호로 묶으면 된다.\")]),e._v(\" \"),t(\"p\",[e._v(\"조건연산은 C나 C++의 경우에는 삼항연산을 이용한다.\")]),e._v(\" \"),t(\"p\",[e._v(\"피연산자 순서\"),t(\"br\"),e._v(\"\\n변수나 상수는 순서가 크게 상관이 없다.\"),t(\"br\"),e._v(\"\\n괄호가 있거나 함수호출이 있는 경우에는 결과 값을 피연산자로 들어가야하기 때문에 먼저 결과 값을 얻어야한다.\")]),e._v(\" \"),t(\"p\",[e._v(\"만약에, a*b에 side effect가 존재한다면 순서가 달라진다.\"),t(\"br\"),e._v(\"\\nFunctional side effect는 함수 안에서 전역 변수나 매개변수의 값을 바꿀 때 side effect가 있다고 한다.\"),t(\"br\"),e._v(\"\\na = 10; b = a + func(a);\"),t(\"br\"),e._v(\"\\n왼쪽을 먼저하면 변수 b에 20이 할당되지만, 오른쪽을 먼저하면 변수 b에 30이 할당된다.\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"int a = 5;\\nitn fun1() {\\n\\ta = 17;\\n\\treturn 3;\\n}\\nvoid main() {\\n\\ta = a + fun1();\\n}\\n\")])])]),t(\"p\",[e._v(\"C언어의 경우에는 정의되어 있지 않다. 따라서 fun1을 먼저 하면 a = 20이 되고 왼쪽을 먼저 시작하면 8이 된다. 따라서 C언어에서 구현할 때는 피해야한다.\")]),e._v(\" \"),t(\"p\",[t(\"strong\",[e._v(\"Referential Transparency\")]),e._v(\"의 특징이란 Side effect가 없어야한다.\"),t(\"br\"),e._v(\"\\n예를 들어 \"),t(\"code\",[e._v(\"result1 = (fun(a) + b) / (fun(a) - c);\")]),t(\"br\"),e._v(\" \"),t(\"code\",[e._v(\"temp = fun(a); result2 = (temp + b) / (temp -c);\")]),t(\"br\"),e._v(\"\\n이때, result1과 result2가 같다면 Referential Transparency를 가지고 있다고 할 수 있다.\"),t(\"br\"),e._v(\"\\n이러한 특징을 보면 Assignment가 없는 pure functional language는 항상 Referential Transparency를 갖는다.\"),t(\"br\"),e._v(\"\\n장점 : 프로그램을 이해하기 쉬워진다.\")]),e._v(\" \"),t(\"h2\",{attrs:{id:\"operator-overloading\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#operator-overloading\"}},[e._v(\"#\")]),e._v(\" Operator Overloading\")]),e._v(\" \"),t(\"p\",[e._v(\"자료형 별로 연산을 다르게 정의해놓았다. 이 부분을 오버로딩했다고 할 수 있다. 프로그래머 입장에서는 익숙한 기호로 사용할 수 있다는 장점이 있다.\"),t(\"br\"),e._v(\"\\n하지만 C와 C++에서 \"),t(\"code\",[e._v(\"&, -, *\")]),e._v(\"은 뜻이 애매해서 컴파일러가 오류를 검출하는데 있어서 문제가 생길 수 있다. 추가적으로 가독성에도 문제가 있을 수 있다.\"),t(\"br\"),e._v(\"\\n예를 들어서 x = &y인 경우 프로그래머의 실수로 x = x & y을 잘못 기입한 경우 오류를 탐지하지 못하는 문제가 생길 수 있다는 것이다.\"),t(\"br\"),e._v(\"\\nC++과 C#, F#에서 user-defined overloaded operator을 만들 수 있다.\"),t(\"br\"),e._v(\"\\n예를 들어 A * B + C * D(MatrixAdd(MatrixMult(A, B), MatrixMult(C, D))와 같이 배열 자료형끼리의 연산을 오버로딩하면 이러하게 편하게 코딩이 가능하며, 가독성이 증가한다.\"),t(\"br\"),e._v(\"\\n하지만 잠재적인 문제로 사용자가 센스없이 오버로딩하게 된다면 가독성도 떨어질 수 있다.\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[e._v(\"Type Conversions\")]),t(\"br\"),e._v(\"\\n만약 컴파일러가 자동으로 해준다면 \"),t(\"code\",[e._v(\"Coercion\")]),e._v(\"이라고 한다.\")])]),e._v(\" \"),t(\"h2\",{attrs:{id:\"narrowing-conversion\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#narrowing-conversion\"}},[e._v(\"#\")]),e._v(\" Narrowing conversion\")]),e._v(\" \"),t(\"p\",[e._v(\"원본의 값을 변환 시 잃어버리는 값이 있으면 Narrowing conversion이라고 한다. ex) 1.2 -> 1 (float -> int)\"),t(\"br\"),e._v(\"\\nWidening conversion\"),t(\"br\"),e._v(\"\\n원본이 값을 변환 시 그대로 다 갖고 더 크게 변환 해주는 것이다.\"),t(\"br\"),e._v(\"\\n따라서 안정적이며, Coercion을 허용한다.\"),t(\"br\"),e._v(\"\\nex) 1 -> 1.0 (int -> float)\")]),e._v(\" \"),t(\"p\",[e._v(\"Mixed Mode operation일 경우 coercion이 묵시적으로 일어나게 된다. coercion이 일어나게 되면 컴파일러가 \"),t(\"em\",[e._v(\"타입 오류\")]),e._v(\"를 탐지 못하는 경우가 있을 수 있다.\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"int a;\\nfloat b, c, d;\\n...\\nd = b * a; // (c를 써야하나 실수 한 경우)\\n\")])])]),t(\"p\",[e._v(\"추가적으로 C언어나 Java에서 integer보다 작은 타입의 경우에는 integer로 coercion하고 연산을 한뒤 다시 값에 coercion해준다.\")]),e._v(\" \"),t(\"p\",[e._v(\"C언어에서 프로그래머가 명시적으로 형변환하는 경우에는 변수 앞에 적어준다.\")]),e._v(\" \"),t(\"p\",[e._v(\"예외처리가 필요한 표현이 있다.\"),t(\"br\"),e._v(\"\\ndivison by zero\"),t(\"br\"),e._v(\"\\noverflow\")]),e._v(\" \"),t(\"p\",[e._v(\"관계식\"),t(\"br\"),e._v(\" \"),t(\"code\",[e._v(\"< > <= >= == != /= ~=\")]),e._v(\"등 사용된다.\"),t(\"br\"),e._v(\"\\nJavascript와 PHP에서의 \"),t(\"code\",[e._v(\"==\")]),e._v(\"와 \"),t(\"code\",[e._v(\"===\")]),e._v(\"의 차이를 보자\"),t(\"br\"),e._v(\" \"),t(\"code\",[e._v(\"==\")]),e._v(\"은 coerced가 일어난 뒤 비교를 한다. 하지만 \"),t(\"code\",[e._v(\"===\")]),e._v(\"은 coerced가 일어나지 않는다.\")]),e._v(\" \"),t(\"p\",[e._v(\"Boolean\"),t(\"br\"),e._v(\"\\nC에서는 0이 거짓, 0이 아니면 참이다. 잘못된 표현중 하나는 \"),t(\"code\",[e._v(\"if(a<b<c)\")]),e._v(\"이다. \"),t(\"code\",[e._v(\"a<b\")]),e._v(\"을 먼저 실행한다음 1 혹은 0이랑 c를 비교한 값을 if 조건문에 넣게 된다.\"),t(\"br\"),e._v(\"\\n고치게되면 \"),t(\"code\",[e._v(\"if(a<b && b<c)\")]),e._v(\"로 고쳐야한다.\")]),e._v(\" \"),t(\"p\",[t(\"strong\",[e._v(\"Short Circuit Evaluation\")]),t(\"br\"),e._v(\"\\n전체를 evaluation을 하지 않고도 일부분을 evaluation을 해도 값을 얻을 수 있는 경우를 Short Circuit Evaluation이라고 한다.\"),t(\"br\"),e._v(\"\\nex) (13 * a) * (b / 13 - 1)\"),t(\"br\"),e._v(\"\\n만약 a가 0이라면 (b / 13 - 1)하면 된다.\"),t(\"br\"),e._v(\"\\n지원하지 않는 경우 일어나는 문제\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"index = 0;\\nwhile (index < length> && (LIST[index] != value))\\n\\tindex++;\\n\")])])]),t(\"p\",[e._v(\"만약 길이가 length와 같아진 경우 false가 반환되나, 뒤에도 evaluation을 해야하므로 LIST[length]가 들어가게 되어 세그먼트 폴트가 일어날 수 있다.\"),t(\"br\"),e._v(\"\\ne.g (a > b) || (b++ / 3)\"),t(\"br\"),e._v(\"\\n여기서는 선조건인 (a>b)가 false여야 뒷조건을 실행하므로 b++가 무조건 일어나지는 않는다. 하지만 이렇게 side effect가 있도록 코딩하지 않도록 해야한다.\")]),e._v(\" \"),t(\"h2\",{attrs:{id:\"assignment\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#assignment\"}},[e._v(\"#\")]),e._v(\" Assignment\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"general-syntax\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#general-syntax\"}},[e._v(\"#\")]),e._v(\" general syntax\")]),e._v(\" \"),t(\"p\",[t(\"code\",[e._v(\"<target_var> <assign_operator> <expression>\")]),t(\"br\"),e._v(\"\\nassign_opeartor는 FOTRAN, BASIC, C기반 언어는 \"),t(\"code\",[e._v(\"=\")]),e._v(\"을 사용한다. Ada같은 경우에는 \"),t(\"code\",[e._v(\":=\")]),e._v(\"을 사용한다.\")]),e._v(\" \"),t(\"p\",[e._v(\"compound assignment operator\"),t(\"br\"),e._v(\" \"),t(\"code\",[e._v(\"a = a + b\")]),e._v(\" ==> \"),t(\"code\",[e._v(\"a += b\")])]),e._v(\" \"),t(\"p\",[e._v(\"Unary assignment operator\"),t(\"br\"),e._v(\" \"),t(\"code\",[e._v(\"sum = ++count\")]),e._v(\" // count 연산 먼저\"),t(\"br\"),e._v(\" \"),t(\"code\",[e._v(\"sum = count++\")]),e._v(\" // 할당 먼저\\n\"),t(\"code\",[e._v(\"count++\")]),t(\"br\"),e._v(\" \"),t(\"code\",[e._v(\"-count++\")]),e._v(\"// count 연산 후 -붙인다.\")]),e._v(\" \"),t(\"p\",[e._v(\"Perl의 조건 할당\"),t(\"br\"),e._v(\" \"),t(\"code\",[e._v(\"($flag ? $total : $subtotal) = 0\")]),t(\"br\"),e._v(\"\\n이것은 밑에 코드와 같다.\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"if ($flag)\\n\\t$total = 0\\nelse\\n\\t$subtotal = 0\\n\")])])]),t(\"h3\",{attrs:{id:\"assignment-as-an-expreesion\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#assignment-as-an-expreesion\"}},[e._v(\"#\")]),e._v(\" Assignment as an Expreesion\")]),e._v(\" \"),t(\"p\",[t(\"code\",[e._v(\"whlie((ch = getchar()) != EOF)\")]),e._v(\"\\n상수랑 assignment statement와 비교하는 경우이다.\"),t(\"br\"),e._v(\"\\nside effect가 일어날 수 있다. 그로 인해 가독성이 떨어질 수 있다.\"),t(\"br\"),e._v(\"\\nE.g \"),t(\"code\",[e._v(\"a = b + (c = d / b) -1\")]),t(\"br\"),e._v(\"\\n변수 c에 d/b 값을 할당 후 b + c - 1을 계산하여 변수 a에 할당한다.\")]),e._v(\" \"),t(\"p\",[e._v(\"Multiple Assignments\"),t(\"br\"),e._v(\"\\nPerl, Ruby, Lua에서 Tuple을 사용하면 ($first, $second, $third) = (20, 30, 40);\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"함수형-언어에서의-할당\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#함수형-언어에서의-할당\"}},[e._v(\"#\")]),e._v(\" 함수형 언어에서의 할당\")]),e._v(\" \"),t(\"p\",[e._v(\"ML에서 \"),t(\"code\",[e._v(\"val fruit = apples + oranges;\")]),t(\"br\"),e._v(\"\\n을 사용하게되면 fruit에 apples + oranges의 값이 바인딩되어 수정이 불가능하다. 따라서 변수들의 재사용이 불가능하다. 매번 변수들을 선언해서 사용해야 하므로 Cache을 사용하지 못하게된다. 따라서 속도가 느릴 수 밖에 없다.\")])])}),[],!1,null,null,null);a.default=r.exports}}]);","extractedComments":[]}