{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{369:function(v,_,a){\"use strict\";a.r(_);var n=a(42),e=Object(n.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"names-bindings-and-scopes\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#names-bindings-and-scopes\"}},[v._v(\"#\")]),v._v(\" Names, Bindings, and Scopes\")]),v._v(\" \"),a(\"p\",[v._v(\"명령형언어는 폰노이만 아키텍쳐를 추상한다.\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"명령과 데이터는 메모리에 저장된다.\")]),v._v(\" \"),a(\"li\",[v._v(\"cpu에 의해서 필요한 연산이 실행된다.\")])]),v._v(\" \"),a(\"p\",[v._v(\"명령형의 언어 피연산자를 담당하는 memory cell이 variables(변수)다.\")]),v._v(\" \"),a(\"h2\",{attrs:{id:\"변수의-여러-속성\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#변수의-여러-속성\"}},[v._v(\"#\")]),v._v(\" 변수의 여러 속성\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"name\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#name\"}},[v._v(\"#\")]),v._v(\" Name\")]),v._v(\" \"),a(\"p\",[v._v(\"변수의 이름, 함수의 이름, 매개변수 이름, 구조체\"),a(\"br\"),v._v(\"\\nIdentifier와 상호호환되게 사용\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"Length\\n\"),a(\"ul\",[a(\"li\",[v._v(\"자유도 증가\")]),v._v(\" \"),a(\"li\",[v._v(\"컴파일타임 ↓\"),a(\"br\"),v._v(\"\\n∵ Symbol table에 넣음\")]),v._v(\" \"),a(\"li\",[v._v(\"메모리 ↑\"),a(\"br\"),v._v(\"\\n∵ 런타임에 기록시 실행시간 ↓와 함께\")])])]),v._v(\" \"),a(\"li\",[v._v(\"Form\\n\"),a(\"ul\",[a(\"li\",[v._v(\"underscore (\"),a(\"code\",[v._v(\"_\")]),v._v(\")을 대체해서 Camel notation 사용\"),a(\"br\"),v._v(\"\\nScoreValue instead of score_value\")]),v._v(\" \"),a(\"li\",[v._v(\"PHP\"),a(\"br\"),v._v(\" \"),a(\"code\",[v._v(\"$\")]),v._v(\" 로 변수 선언\"),a(\"br\"),v._v(\"\\ne.g. $scoreValue\")]),v._v(\" \"),a(\"li\",[v._v(\"Perl\"),a(\"br\"),v._v(\"\\nScalar $\"),a(\"br\"),v._v(\"\\nArray @\"),a(\"br\"),v._v(\"\\nHash %\"),a(\"br\"),v._v(\"\\n변수 선언\")])])]),v._v(\" \"),a(\"li\",[v._v(\"Case sensitivity\\n\"),a(\"ul\",[a(\"li\",[v._v(\"C기반 언어는 대소문자 구별한다. 이것은 가독성을 떨어트린다고 하는데 사람마다 다르다.\")])])]),v._v(\" \"),a(\"li\",[v._v(\"Special words\\n\"),a(\"ul\",[a(\"li\",[v._v(\"가독성을 높일 수 있지만 Reserved word(예약어)가 지정되있는 경우 피해야한다.\")]),v._v(\" \"),a(\"li\",[v._v(\"예약어가 많으면 유저가 예약어를 피해서 변수를 써야하지만 부족하다면 불편하다.\")])])])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"variables\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#variables\"}},[v._v(\"#\")]),v._v(\" Variables\")]),v._v(\" \"),a(\"p\",[v._v(\"변수는 memory cell을 매핑한것이다.\"),a(\"br\"),v._v(\"\\n특성 : name, address, value, type, lifetime, scope\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[a(\"p\",[v._v(\"Name\"),a(\"br\"),v._v(\"\\n앞에서 정리한 것과 같다.\")])]),v._v(\" \"),a(\"li\",[a(\"p\",[v._v(\"Address\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"C Pointer와 같이 변수와 연관된 메모리의 주소이다.\")]),v._v(\" \"),a(\"li\",[v._v(\"변수가 함수 속에서 다른 주소를 가질 수 있다. (10강에서 계속)\")]),v._v(\" \"),a(\"li\",[v._v(\"L-value(변수의 주소)와 같다.\")]),v._v(\" \"),a(\"li\",[v._v(\"Alias : 같은 주소에 다른 이름 (C 포인터 C++ 참조자) 가독성 저하\")])])]),v._v(\" \"),a(\"li\",[a(\"p\",[v._v(\"Type\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"변수 값의 범위와 어떤 연산을 쓸지 결정한다.\")])])]),v._v(\" \"),a(\"li\",[a(\"p\",[v._v(\"Value\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[a(\"em\",[v._v(\"Abstract memory cell\")]),v._v(\" : 물리적 cell 이나 변수와 연관된 cell\")]),v._v(\" \"),a(\"li\",[v._v(\"l-value : address\")]),v._v(\" \"),a(\"li\",[v._v(\"r-value : value\")])])]),v._v(\" \"),a(\"li\",[a(\"p\",[a(\"strong\",[v._v(\"Binding\")]),a(\"br\"),v._v(\"\\n권한과 속성 사이의 연관이다.\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"변수의 type과 value, operation과 symbol\"),a(\"br\"),v._v(\"\\nbinding time에 따라 static과 dynamic으로 나뉘어진다.\"),a(\"br\"),v._v(\"\\nLanguage design time, implementation time, compile time은 static binding time\"),a(\"br\"),v._v(\"\\n따라서, static binding은\\n\"),a(\"ol\",[a(\"li\",[v._v(\"런타임 전\")]),v._v(\" \"),a(\"li\",[v._v(\"프로그램 실행 중 바뀌지 않으면\")])])])]),v._v(\" \"),a(\"p\",[v._v(\"Load time과 Runtime, global은 dynamic binding time 은 dynamic binding time으로,\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"실행중에 처음 발생하거나\")]),v._v(\" \"),a(\"li\",[v._v(\"프로그램 실행 중에 바뀔 수 있으면\\ndynamic binding이다.\")])]),v._v(\" \"),a(\"p\",[v._v(\"Type Binding은 변수가 프로그램에 참조되기전에 자료형이 바운딩되어야한다. 만약 static binding인 경우 explicit 혹은 implicit 선언이 있어야한다.\")]),v._v(\" \"),a(\"p\",[v._v(\"Static Type Binding\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"명시적 선언\\n\"),a(\"ul\",[a(\"li\",[v._v(\"프로그래머가 직접 명시해서 선언하는 경우\")])])]),v._v(\" \"),a(\"li\",[v._v(\"묵시적 선언\\n\"),a(\"ul\",[a(\"li\",[v._v(\"컴파일러가 자동으로 타입을 찾아내는 묵시적 선언\")]),v._v(\" \"),a(\"li\",[v._v(\"default convention\"),a(\"br\"),v._v(\"\\n지정하지 않으면 자동으로 default에 들어감\\n\"),a(\"ol\",[a(\"li\",[v._v(\"naming convention\"),a(\"br\"),v._v(\"\\nFotran에서 사용, 타이핑시에 잘못 치는 경우 잘못된 자료형이 바인딩되어 에러가 일어날 수 있다.\")]),v._v(\" \"),a(\"li\",[v._v(\"Using context\"),a(\"br\"),v._v(\"\\n타입을 추론하는 방식 ex) var 타입 초기화 값을 보고 추정함 (컴파일 시간에 결정되므로 static)\")])])])])])]),v._v(\" \"),a(\"p\",[v._v(\"Dynamic Type Binding\"),a(\"br\"),v._v(\"\\n바인딩된 자료형 외의 다른 자료형으로 바뀌는 경우 (주소와 메모리셀이 바뀔 수 있음)\")]),v._v(\" \"),a(\"p\",[v._v(\"장점 : 프로그래밍 유연성 ↑\"),a(\"br\"),v._v(\"\\ntype명시로 인한 재사용률 ↑\"),a(\"br\"),v._v(\"\\n단점 : 신뢰성 ↓\"),a(\"br\"),v._v(\"\\n변수들이 런타임에 새로운 자료형을 가질 수 있어서 메모리 ↑\"),a(\"br\"),v._v(\"\\n타입체크를 해야하므로 속도 ↓\")])])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"lifetime\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#lifetime\"}},[v._v(\"#\")]),v._v(\" Lifetime\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"어떤 메모리 셀에 바운딩되냐에 따라 다르다.\")]),v._v(\" \"),a(\"li\",[v._v(\"static (data)\\n\"),a(\"ul\",[a(\"li\",[v._v(\"실행 전 메모리 셀에 바운딩\")]),v._v(\" \"),a(\"li\",[v._v(\"실행 이후에 값 바뀌지 않음.\")]),v._v(\" \"),a(\"li\",[v._v(\"재귀x\")])])]),v._v(\" \"),a(\"li\",[v._v(\"dynamic (heap, stack)\\n\"),a(\"ul\",[a(\"li\",[v._v(\"stack-dynamic (stack)\\n\"),a(\"ul\",[a(\"li\",[v._v(\"재귀 허용\")]),v._v(\" \"),a(\"li\",[v._v(\"할당과 해지시의 오버헤드 존재\")]),v._v(\" \"),a(\"li\",[v._v(\"Subprogram이 history senstive하지 않다.\")]),v._v(\" \"),a(\"li\",[v._v(\"비효율적인 참조(간접 주소)\")])])]),v._v(\" \"),a(\"li\",[v._v(\"explicit heap-dynamic(heap) 명시적 동적할당\\n\"),a(\"ul\",[a(\"li\",[v._v(\"자료형은 컴파일 시간에 바운드 되지만 메모리에 적재는 런타임에 일어난다.\")]),v._v(\" \"),a(\"li\",[v._v(\"new delete\")]),v._v(\" \"),a(\"li\",[v._v(\"동적으로 저장공간관리\")]),v._v(\" \"),a(\"li\",[v._v(\"복잡하거나 어렵다.\")])])]),v._v(\" \"),a(\"li\",[v._v(\"implicit head-dynamic(heap) 컴파일러가 할당 및 해제\\n\"),a(\"ul\",[a(\"li\",[v._v(\"선언된 자료형과 다른 자료형으로 할당이 가능하다.\")]),v._v(\" \"),a(\"li\",[v._v(\"높은 유연성\")]),v._v(\" \"),a(\"li\",[v._v(\"런타임 오버헤드\")]),v._v(\" \"),a(\"li\",[v._v(\"컴파일러가 오류 탐색기능 손실\")])])])])])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"scope\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#scope\"}},[v._v(\"#\")]),v._v(\" Scope\")]),v._v(\" \"),a(\"p\",[v._v(\"scope란 쓰이고 읽히는 범위\"),a(\"br\"),v._v(\"\\n지역변수는 선언된 프로그램 유닛의 한정된다.\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[a(\"p\",[v._v(\"nonlocal 변수\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"전역변수\")])])]),v._v(\" \"),a(\"li\",[a(\"p\",[v._v(\"Scope rules\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"nonlocal 변수에 대해서만 적용됨\")])])]),v._v(\" \"),a(\"li\",[a(\"p\",[v._v(\"Static Scope\"),a(\"br\"),v._v(\"\\n사람이나 컴파일러가 실행 전에 소스만 보고 알 수 있으면 Static한 변수\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[a(\"p\",[a(\"strong\",[v._v(\"subprogram can be nested\")]),v._v(\"\\nsubprogram 중첩 가능\\n속도 ↓\")])]),v._v(\" \"),a(\"li\",[a(\"p\",[v._v(\"subprogram cannot be nested\"),a(\"br\"),v._v(\"\\nsubprogram 중첩 불가능\\n속도 ↑ (C기반언어)\")])])])])]),v._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[v._v(\"func big() {\\n    func sub1() {\\n        var x = 7;\\n        sub2();\\n    }\\n    func sub2() {\\n        var y = x; // x nonlocal 변수 (static scope일 때는 big의 x)\\n    }\\n    var x = 3;\\n    sub1();\\n}\\n\")])])]),a(\"p\",[v._v(\"big에 의해서 sub1에 \"),a(\"code\",[v._v(\"x\")]),v._v(\"가 가려진 걸 \"),a(\"code\",[v._v(\"hidden\")]),v._v(\" or \"),a(\"code\",[v._v(\"closer\")]),v._v(\"변수라고 한다.\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"block\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#block\"}},[v._v(\"#\")]),v._v(\" Block\")]),v._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[v._v(\"void sub() {\\n    int count;\\n    while(...) {\\n        int count;\\n        count++;\\n        ...\\n    }\\n}\\n\")])])]),a(\"p\",[v._v(\"C와 C++에서는 허용하나, JAVA와 C#은 허용하지 않는다. 속도면에서는 좋지 않다. 할당과 해지 반복을 한다.\")]),v._v(\" \"),a(\"p\",[v._v(\"함수형 언어는 \"),a(\"code\",[v._v(\"let\")]),v._v(\"키워드로 블록을 구성한다.\"),a(\"br\"),v._v(\"\\nScheme\")]),v._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[v._v(\"(LET (\\n    (top (+ a b))\\n    (bottom (- c d))/ top bottom)\\n)\\n\")])])]),a(\"p\",[v._v(\"ML\")]),v._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[v._v(\"let\\n    val top = a + b\\n    val bottom = c -d\\nin\\n    top / bottom\\nend\\n\")])])]),a(\"p\",[v._v(\"추가적으로 함수언어는 매번 변수를 만들어서 사용한다.\")]),v._v(\" \"),a(\"p\",[v._v(\"Blcok의 Scope는 선언부터 Block 끝까지\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"global-scope\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#global-scope\"}},[v._v(\"#\")]),v._v(\" Global Scope\")]),v._v(\" \"),a(\"p\",[v._v(\"블록 밖에서 전역변수로 정의되면 어디서든 사용할 수 있다.\"),a(\"br\"),v._v(\"\\nC언어에서는 오직 한번만 정의해야한다.\\nextern으로 다른 파일에서 특정한 변수를 받아와서 사용하는 것도 전역변수로 사용할 수 있다.\")]),v._v(\" \"),a(\"p\",[v._v(\"PHP의 경우에 전역변수를 사용할 때는 global로 선언하거나 $GLOBALS로 사용해야한다.\")]),v._v(\" \"),a(\"p\",[v._v(\"Python 또한, 전역변수와 지역변수가 이름이 같은 경우에는 명시적으로 global로 선언해주어야한다.\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"dynamic-scope\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#dynamic-scope\"}},[v._v(\"#\")]),v._v(\" Dynamic Scope\")]),v._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",[a(\"code\",[v._v(\"non-local 변수에 대해서는 실행시간에 콜체인을 따라가서 호출한 caller를 확인해야한다.\\n\")])])]),a(\"h2\",{attrs:{id:\"scope-정리\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#scope-정리\"}},[v._v(\"#\")]),v._v(\" \"),a(\"strong\",[v._v(\"Scope 정리\")])]),v._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[v._v(\"func big() {\\n\\tfunc sub1() {\\n\\t\\tvar x = 7;\\n\\t\\tsub2();\\n\\t}\\n\\tfunc sub2() {\\n\\t\\tvar y = x;\\n\\t}\\n\\tvar x = 3;\\n\\tsub1();\\n}\\n\")])])]),a(\"p\",[v._v(\"Static Scoping인 경우엔 sub2의 x를 big의 x를 참조한다.\"),a(\"br\"),v._v(\"\\nDynamic Scoping인 경우엔 sub2의 x를 sub1의 x를 참조한다.\")]),v._v(\" \"),a(\"p\",[v._v(\"Dynamic Scoping\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"장점 : 편리함\")]),v._v(\" \"),a(\"li\",[v._v(\"단점 : 구현 힘듬, 정적인 타입체크가 불가능, 가독성 저하\")])]),v._v(\" \"),a(\"p\",[v._v(\"Scope와 Lifetime은 관련이 있지만 다른 개념이다.\")]),v._v(\" \"),a(\"p\",[a(\"em\",[v._v(\"referencing environment\")]),v._v(\" : statement에서 보이는 모든 이름의 집합체\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"static-scoped : 콜스택 전체\")]),v._v(\" \"),a(\"li\",[v._v(\"dynamic-scoped : 콜체인\")])]),v._v(\" \"),a(\"p\",[a(\"em\",[v._v(\"active\")]),v._v(\" : subprogram이 콜 후 리턴 전\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"Named Constants\"),a(\"br\"),v._v(\"\\n상수들은 처음에 한번 값을 바운딩해주고 계속 사용된다.\"),a(\"br\"),v._v(\"\\n가독성과 변경하는데 용이하다는 장점이 있다.\"),a(\"br\"),v._v(\"\\nAda, C++, JAVA는 동적으로 바운딩\"),a(\"br\"),v._v(\"\\nC#은 readonly(동적으로 바운딩), const(컴파일 시간에 바운딩) 두개 사용\\n\"),a(\"ul\",[a(\"li\",[v._v(\"초기화 :\"),a(\"br\"),v._v(\"\\nstatic : 제한O\"),a(\"br\"),v._v(\"\\ndynamic : 제한X\")])])])])])}),[],!1,null,null,null);_.default=e.exports}}]);","extractedComments":[]}