{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{374:function(t,e,n){\"use strict\";n.r(e);var r=n(42),i=Object(r.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[n(\"h1\",{attrs:{id:\"cpu-synchronization\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cpu-synchronization\"}},[t._v(\"#\")]),t._v(\" CPU Synchronization\")]),t._v(\" \"),n(\"h2\",{attrs:{id:\"race-condition\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#race-condition\"}},[t._v(\"#\")]),t._v(\" Race Condition\")]),t._v(\" \"),n(\"p\",[t._v(\"CPU 동기화하는데에 있어 \"),n(\"strong\",[t._v(\"Race Condition\")]),t._v(\" 문제점이 있는데\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"//count = 5일때 counter++, counter-- 연산\\nS0: producer execute register1 = counter {register1 = 5}  \\nS1: producer execute register1 = register1 + 1 {register1 = 6}  \\nS2: consumer execute register2 = counter{register2 = 5}  \\nS3: consumer execute register2 = register2 –1 {register2 = 4}  \\nS4: producer execute counter = register1 {counter = 6 }  \\nS5: consumer execute counter = register2 {counter = 4}\\n\")])])]),n(\"p\",[t._v(\"이런식으로 실행할 때마다 답이 달라지는 경우를 Race Condition이라고 한다.\")]),t._v(\" \"),n(\"h2\",{attrs:{id:\"critical-section\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#critical-section\"}},[t._v(\"#\")]),t._v(\" Critical Section\")]),t._v(\" \"),n(\"p\",[t._v(\"프로세스끼리 변수를 공유하여 만들어진 시스템에 있어서 같은 변수를 사용하거나 table을 업데이트하거나 file을 쓰는 코드가 쓰인 부분을 \"),n(\"strong\",[t._v(\"Critical Section\")]),t._v(\"이라고 한다.\"),n(\"br\"),t._v(\"\\nCritical Section은 Entry Section과 Exit Section으로 나누어지는데 나머지를 Remainder Section이라 부른다.\"),n(\"br\"),t._v(\" \"),n(\"img\",{attrs:{src:\"https://www.geeksforgeeks.org/wp-content/uploads/gq/2015/06/critical-section-problem.png\",alt:\"Critical Section\"}}),n(\"br\"),t._v(\"\\nCritical Section은 3가지 필요조건을 만족해야한다.\"),n(\"br\"),t._v(\" \"),n(\"em\",[t._v(\"1. Mutual Exclusion\")]),t._v(\" - 한 프로세스가 C-S을 수행중이라면 다른 프로세스들은 C-S을 수행할 수 없다.\"),n(\"br\"),t._v(\" \"),n(\"em\",[t._v(\"2. Progress\")]),t._v(\" - C-S을 수행하는 프로세스가 없고 C-S을 수행하고자하는 프로세스가 있을 때 반드시 수행되어야 한다.\"),n(\"br\"),t._v(\" \"),n(\"em\",[t._v(\"3. Bounded Waiting\")]),t._v(\" - C-S을 요청한 프로세스는 무한히 대기하면 안된다.\"),n(\"br\"),t._v(\"\\n이 세가지 조건을 다 만족한 Peterson's Solution을 봐보자\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"// int turn = 0; bool flag[3]; flag[1] = flag[2] = false;\\n//Process P₁\\t\\t\\t|\\t//Process P₂\\nflag[1] = true;\\t\\t\\t|\\tflag[2] = true;\\nturn = 1;\\t\\t\\t|\\tturn = 0;\\nwhile (flag[2] && (turn == 1));\\t|\\twhile (flag[1] && (turn == 0));\\n\\tcritical section\\t|\\t\\tcritical section\\nflag[1] = false;\\t\\t|\\tflag[2] = false;\\n\\tremainder section\\t|\\t\\tremainder section\\n\")])])]),n(\"p\",[t._v(\"이러한 3가지 조건을 만족하는 해결법은 크게 소프트웨어적, 하드웨어적 해결법으로 나뉜다.\"),n(\"br\"),t._v(\"\\n소프트웨어적 해결법은 test_and_set과 compare_and_swap 등이 있다.\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"boolean test_and_set (boolean * target) {\\n\\tboolean rv = *target;\\n\\t*target = TRUE;\\n\\treturn rv;\\n}\\n// 인자 값을 그대로 반환하되, 인자를 TRUE로 변경한다.\\ndo{\\n\\twhile (test_and_set(&lock)); /* do nothing */\\n\\t\\t/* critical section */\\n\\tlock = false;\\n\\t\\t/* remainder section */\\n\\t} while (true);\\n// lock이 false로 초기화되어있으므로 처음엔 바로 C-S을 수행하지만 lock이 true가 되어 다른 프로세스들은 수행하지 못한다. 이후 lock을 바꾸면서 수행하여 Mutual Exclusion 조건을 해결하였다.\\n\\ndo {\\n\\twaiting[i] = true;\\n\\tkey = true;\\n\\twhile (waiting[i] && key)\\n\\t\\tkey = test_and_set(&lock);\\n\\twaiting[i] = false;\\n\\t/* critical sectioin */\\n\\tnext = (i+1) % n;\\n\\twhile ((next != i) && !waiting[next])\\n\\t\\tnext = (next + 1) % n;\\n\\tif (next == i)\\n\\t\\tlock = false;\\n\\telse\\n\\t\\twaiting[next] = false;\\n\\t/*remainder section */\\n} while (true);\\n이 코드는 Bounded Waiting도 해결한 코드이다.\\n\")])])]),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"int compare_and_swap(int *value, int expected, int new_value) {\\n\\tint temp = *value;\\n\\tif (*value == expected)\\n\\t\\t*value = new_value;\\n\\treturn temp;\\n}\\ndo {\\n\\twhile (compare_and_swap(&lock, 0, 1) != 0);\\n\\t\\t\\t/* do nothing */\\n\\t\\t/* ciritcal section */\\n\\tlock = 0;\\n\\t\\t/* remainder section */\\n\\t} while (true);\\n이 방법 또한 Mutual exlusion 을 해결했다. 차이점은 반환형이 다르다는 점이다.\\n\")])])]),n(\"h3\",{attrs:{id:\"하드웨어적-해결법\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#하드웨어적-해결법\"}},[t._v(\"#\")]),t._v(\" 하드웨어적 해결법\")]),t._v(\" \"),n(\"p\",[t._v(\"하드웨어적 해결법은 3가지가 있다.\"),n(\"br\"),t._v(\" \"),n(\"strong\",[t._v(\"1. Mutex lock (spinlock)\")]),t._v(\" - 가장 기본적인 형태의 방법이다. acquire()와 release()로 잠금과 잠금해제를 한다. 잠그면 CS에 접근할 수 없다. test__and_set과 비슷하나, busy wait을 사용하므로 cpu를 계속 사용한다. 빠른 진입이 가능하나, CPU가 낭비된다. 따라서 CPU을 낭비 안할 때나, 금방 이용가능 할 때, Critical Section이 짧은 경우 사용되면 좋다.\"),n(\"br\"),t._v(\" \"),n(\"strong\",[t._v(\"2. Semaphore\")]),t._v(\" - Binary와 Counting으로 나뉘어서 spinlock과 비슷하게 P() == wait()과 V() == signal()을 사용한다. Counting Semaphore는 Critical Section에 들어갈 수 있는 프로세스 갯수를 S 변수에 넣어 여러개로 관리가 가능하다. Binary Semaphore은 Mutex Lock와 같다. Busy wait을 사용유무로 종류가 네 가지가 나온다. 그 중에 일반적인 세마포어는 Counting하며, Non-busy wait을 사용하는 세마포어이다. 따라서 context switch 시간보다 길고 연산외에 시스템콜이나 예측불가한 작업시에는 세마포어를 사용하고 Critical Section 진입이 시간이 짧다면 스핀 락을 사용하는게 맞다.\"),n(\"br\"),t._v(\" \"),n(\"em\",[t._v(\"3. Monitor\")]),t._v(\" - 가장 high-level부분으로 가장 사용하기 편한 방법이라고 하나 크게 다루지 않았다.\"),n(\"br\"),t._v(\"\\n추가적으로 Deadlock과 Starvation이 있는데\"),n(\"br\"),t._v(\"\\n먼저 Deadlock은 여러 프로세스들이 수행될 때 프로세스 전부 wait상태에 빠진 경우다.\"),n(\"br\"),t._v(\"\\nStarvation은 특정 프로세스의 우선순위가 낮아서 자원 할당을 받지 못하는 경우이다.\")]),t._v(\" \"),n(\"h2\",{attrs:{id:\"cpu동기화에-신경써야할-문제-3가지\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cpu동기화에-신경써야할-문제-3가지\"}},[t._v(\"#\")]),t._v(\" CPU동기화에 신경써야할 문제 3가지\")]),t._v(\" \"),n(\"h3\",{attrs:{id:\"_1-bounded-buffer-problem\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-bounded-buffer-problem\"}},[t._v(\"#\")]),t._v(\" 1) Bounded-Buffer Problem\")]),t._v(\" \"),n(\"p\",[t._v(\"Bounded-Buffer Problem은 생산자와 소비자가 같은 버퍼를 점유할 때 일어나는 문제이다.\"),n(\"br\"),t._v(\" \"),n(\"em\",[t._v(\"Bounded-Buffer Problem Solution\")]),n(\"br\"),t._v(\"\\nEmpty : 버퍼 내에 저장할 공간이 있음을 표시, 생산자의 진입을 관리\"),n(\"br\"),t._v(\"\\nFull : 버퍼 내에 소비할 아이템이 있음을 표시, 소비자의 진입을 관리\"),n(\"br\"),t._v(\"\\nMutex : 버퍼에 대한 접근을 관리, 생산자와 소비자가 empty, full 세마포어에 진입한 경우 버퍼의 상태 값을 변경하기위한 세마포어\"),n(\"br\"),t._v(\"\\n세마포어 value의 초기값은 full = 0, empty = n, mutex = 1로 생산자와 소비자의 프로세스을 정리한다.\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"생산자 프로세스\\t\\t            \\t\\t\\t|소비자 프로세스      \\n    Do {\\t\\t        \\t\\t        \\t|Do {\\n\\t...\\t\\t\\t\\t                        |\\twait(full);\\n\\t/* produce an item in next_produced */\\t|\\twait(mutex);\\n\\t...                     \\t\\t\\t\\t|\\t...\\n\\twait(empty);\\t\\t\\t            \\t|\\t/* remove an item from buffe to next_consumed */\\n\\twait(mutex);                        \\t|\\t...\\n\\t...         \\t\\t\\t\\t\\t\\t\\t|\\tsignal(mutex);\\n\\t/* add next produced to the buffer */\\t|\\tsignal(empty);\\n\\t...\\t\\t\\t                        \\t|\\t...\\n\\tsignal(mutex);\\t\\t            \\t\\t|\\t/* consume the item in next consumed */\\n\\tsiganl(full);\\t            \\t\\t\\t|\\t...\\n} while(true);\\t\\t\\t\\t            \\t|} while(true);\\n\")])])]),n(\"h3\",{attrs:{id:\"_2-readers-writers-problem\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-readers-writers-problem\"}},[t._v(\"#\")]),t._v(\" 2) Readers-Writers Problem\")]),t._v(\" \"),n(\"p\",[n(\"em\",[t._v(\"Readers-Writers Problem\")]),t._v(\"은\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"Readers : 공유 데이터를 읽는다.\\n\"),n(\"ul\",[n(\"li\",[t._v(\"여러 Reader는 동시에 데이터를 접근할 수 있다.\")])])]),t._v(\" \"),n(\"li\",[t._v(\"Writers : 공유 데이터에 쓴다.\\n\"),n(\"ul\",[n(\"li\",[t._v(\"Writer가 데이터를 수정할 때는 reader나 다른 writer가 접근하면 안된다.\")])])])]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"/* do while 생략 */\\n1)  \\nWriter\\t\\t\\t\\t            \\t\\t    Reader\\nwait(wrt);\\t\\t//entry section\\t\\t\\t    wait(mutex);\\n\\t\\t...\\t\\t\\t    \\t                readcount++;\\nwriting is performed // critical section    if (readcount == 1)\\n\\t\\t...\\t\\t            \\t\\t\\t        wait(wrt);\\t\\t//어떤 writer도 수행X\\nsignal(wrt);\\t//exit section\\t\\t\\t    signal(mutex);\\n\\t\\t\\t\\t\\t                \\t\\t... reading is performed... // critical section\\n\\t\\t\\t\\t                \\t    \\twait(mutex);\\n\\t\\t\\t\\t                \\t\\t    readcount--;\\n\\t\\t\\t\\t                \\t\\t    if (readcount == 0)\\t\\n\\t\\t\\t                \\t\\t\\t\\t    signal(wrt);\\n\\t\\t\\t\\t                \\t\\t    signal(mutex);\\n\")])])]),n(\"p\",[t._v(\"이때 Writer의 Starvation이 일어난다. 그 이유는 계속 Reader들이 진입하게되면 Writer는 Critical section에 진입할 수 없기 때문이다.\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"2)\\nWriter\\t\\t\\t\\t\\t                    \\t|\\tReader\\nwait(wmutex); // Writer Process entry section\\t|\\twait(read); // Reader Process entry section\\nwritedcount++;\\t\\t\\t                \\t\\t|\\tsignal(read);\\nif (writecount == 1)\\t            \\t\\t\\t|\\twait(rmutex);\\n\\twait(read);\\t\\t                    \\t\\t|\\treadcount++;\\nsignal(wmutex);\\t\\t\\t\\t                \\t|\\tif (readcount == 1)\\nwait(wrt);\\t                       \\t\\t\\t\\t|\\t\\twait(wrt);\\n...writing is performed... // critical section\\t|\\tsignal(rmutex);\\nsignal(wrt); // Writer Process exit section\\t    |\\t...reading is performed... // critical section\\nwait(wmutex);\\t                \\t\\t\\t\\t|\\twait(rmutex); // Reader Process exit sectioin\\nwritecount--;\\t\\t\\t\\t\\t                |\\treadcount--;\\nif (writecount == 0)\\t\\t            \\t\\t|\\tif (readcount == 0)\\n\\tsignal(read);\\t\\t\\t                \\t|\\t\\tsignal(wrt);\\nsignal(wmutex);\\t\\t\\t                \\t\\t|\\tsignal(rmutex);\\n\")])])]),n(\"p\",[n(\"code\",[t._v(\"1)\")]),t._v(\"의 Writer의 starvation을 해결하기 위해 짜여졌으나 \"),n(\"code\",[t._v(\"2)\")]),t._v(\"에서는 Reader들이 오히려 starvation에 빠지게 된다.\"),n(\"br\"),t._v(\"\\nReader가 초기값으로 진입했다면 Reader들이 계속 진입하다가 Writer가 진입하게되면 진입한 Reader이 모두 수행하면 Writer가 수행된다. 이 때 Reader가 더 이상 진입하지 못하여 Starvation이 일어난다.\"),n(\"br\"),t._v(\"\\n또, Writer가 초기값으로 진입해서 계속 Writer만 진입한다면 Reader가 Starvation에 빠지게 된다.\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"3)\\nWriter\\t\\t\\t\\t                    \\t\\t|\\tReader\\nwait(mutex); // Writer Process entry section\\t|\\twait(mutex); // Reader Process entry section\\nif(rc>0 || wc>0 || rwc>0 || wwc>0) {\\t    \\t|\\tif(wc>0 || wwc>0) {\\n\\twwc++;\\t                    \\t\\t\\t\\t|\\t\\trwc++;  \\n\\tsignal(mutex);\\t\\t                       \\t|\\t\\tsignal(mutex);\\n\\twait(wrt);\\t\\t\\t\\t                    |\\t\\twait(read);\\n\\twait(mutex);\\t\\t\\t                    |\\t\\twait(mutex);\\n\\twwc--;\\t\\t\\t\\t                    \\t|\\t\\trwc--;\\n}\\t\\t\\t\\t\\t\\t\\t                    |\\t}\\nwc++;\\t\\t\\t\\t\\t\\t                    |\\trc++;\\nsignal(mutex);\\t\\t\\t                    \\t|\\tsignal(mutex);\\n...writing is performed // critical section\\t    |\\t...reading is performed // critical section\\nwait(mutex); // Writer Process exit section\\t    |\\twait(mutex); // Reader Process exit section\\nwc--;\\t\\t\\t\\t\\t\\t                \\t|\\trc--;\\nif(rwc>0) {\\t\\t\\t\\t\\t                \\t|\\tif(rc == 0 && wwc>0)\\n\\tfor (i=0; i<rwc; i++)\\t                \\t|\\t\\tsignal(wrt);\\n\\t\\tsignal(read);\\t\\t                \\t|\\tsignal(mutex);\\n}\\t\\t\\t\\t\\t\\t\\t                \\t|\\nelse\\t\\t\\t\\t\\t\\t                \\t|\\n\\tif (wwc>0) signal(wrt);\\t                \\t|\\nsignal(mutex);\\t\\t\\t\\t                \\t|\\n\")])])]),n(\"p\",[n(\"code\",[t._v(\"3)\")]),t._v(\"의 경우에는 모든 문제가 해결되어 동기화가 잘 이루어진다.\"),n(\"br\"),t._v(\"\\nWriter는 작업이 수행되거나 대기중인 다른 reader, writer가 있다면 대기한다. 그리고 수행 후 대기중인 reader들을 모두 수행한다.\"),n(\"br\"),t._v(\"\\nReader는 writer가 기다리거나 작업중이라면 대기한다. Reader가 다 수행되면 대기 중인 writer을 수행한다.\")]),t._v(\" \"),n(\"h3\",{attrs:{id:\"_3-dining-philosophers-problem\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-dining-philosophers-problem\"}},[t._v(\"#\")]),t._v(\" 3) Dining-Philosophers Problem\")]),t._v(\" \"),n(\"p\",[n(\"em\",[t._v(\"Dining-Philosophers Problem\")]),t._v(\"은 젓가락이 5개가 있을 때 자신과 이웃한 젓가락만 들 수 있으며 젓가락을 2개 들었을 때 식사가 가능하다.\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"1)\\ndo {\\n\\t\\t...\\n\\t\\tthink\\n\\t\\t...\\n\\twait(chopstick[i])\\n\\twait(chopstick[(i+1) % 5])\\n\\t\\t...\\n\\t\\teat\\n\\t\\t...\\n\\tsignal(chopstick[i])\\n\\tsignal(chopstick[(i+1) % 5])\\n\\t\\t...\\n} while(1);\\n\")])])]),n(\"p\",[t._v(\"동시에 젓가락을 집으면 deadlock이 발생한다.\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"2)\\ndo {\\n\\t\\t...\\n\\t\\tthink\\n\\t\\t...\\n\\ttake_chopsticks(i);\\n\\t\\t...\\n\\t\\teat\\n\\t\\t...\\n\\tput_chopsticks(i)\\n\\t\\t...\\n} while(1);\\n\\ntake_chopstics(int i) {\\t\\t|\\t\\tput_chopsticks(int i) {\\n\\twait(mutex);\\t    \\t|\\t\\t\\twait(mutex);\\n\\tstate[i] = HUNGRY;\\t\\t|\\t\\t\\tstate[i] = THINK;\\n\\ttest(i);\\t\\t    \\t|\\t\\t\\ttest(LEFT);\\n\\tsignal(mutex);\\t    \\t|\\t\\t\\ttest(RIGHT);\\n\\tsignal(self[i]);\\t\\t|\\t\\t\\tsignal(mutex);\\n}\\t\\t            \\t\\t|\\t\\t}\\n\\ntest(int i) {\\n\\tif (state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] != EATING) {\\n\\t\\tstate[i] = EATING;\\n\\t\\tsignal(self[i]);\\n\\t}\\n}\\n\")])])]),n(\"p\",[n(\"code\",[t._v(\"2)\")]),t._v(\"의 전략은 철학자들이 좌우 젓가락이 사용 가능할 때 critical section에 진입하여 deadlock과 starvation을 해결하였다.\")])])}),[],!1,null,null,null);e.default=i.exports}}]);","extractedComments":[]}